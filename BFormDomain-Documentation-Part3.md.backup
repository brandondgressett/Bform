# BFormDomain Comprehensive Documentation - Part 3

## Reports System

The Reports System provides flexible report generation capabilities with support for multiple output formats, dynamic data binding, scheduled generation, and template-based layouts. It integrates with the table and entity systems to create rich, data-driven reports.

### Core Components

#### ReportTemplate
Defines the structure and data sources for reports:

```csharp
public class ReportTemplate : IContentType
{
    public string Name { get; set; }                // Unique identifier
    public string Title { get; set; }               // Display name
    public List<string> Tags { get; set; }          // Categorization
    
    // Data sources
    public List<ReportDataSource> DataSources { get; set; } = new();
    
    // Layout
    public ReportLayout Layout { get; set; }         // Layout configuration
    public string? TemplateHtml { get; set; }        // HTML template
    public string? TemplateCss { get; set; }         // Custom CSS
    
    // Output options
    public List<ReportOutputFormat> SupportedFormats { get; set; } = new();
    public ReportOrientation DefaultOrientation { get; set; }
    public string? PageSize { get; set; }            // A4, Letter, etc.
    
    // Parameters
    public List<ReportParameter> Parameters { get; set; } = new();
    
    // Scheduling
    public List<ScheduledEventTemplate> Schedules { get; set; } = new();
    
    // Permissions
    public bool IsVisibleToUsers { get; set; }       // User visibility
    public List<string> AllowedRoles { get; set; } = new();
    
    // Caching
    public int? CacheMinutes { get; set; }           // Cache duration
}

public class ReportDataSource
{
    public string Name { get; set; }                // Source identifier
    public DataSourceType Type { get; set; }        // Source type
    
    // Query configuration
    public string? TableTemplate { get; set; }      // Table source
    public string? EntityType { get; set; }         // Entity source
    public string? QueryName { get; set; }          // Registered query
    public JObject? Filter { get; set; }            // Filter criteria
    public string? OrderBy { get; set; }            // Sort field
    public bool Ascending { get; set; } = true;     // Sort direction
    
    // Aggregation
    public List<AggregationDef>? Aggregations { get; set; }
    public List<string>? GroupBy { get; set; }
    
    // Pagination
    public int? MaxRows { get; set; }               // Row limit
}

public enum DataSourceType
{
    Table = 0,       // Table data
    Entity = 1,      // Entity data
    Query = 2,       // Registered query
    KPI = 3,         // KPI data
    Aggregation = 4  // Aggregated data
}

public class ReportParameter
{
    public string Name { get; set; }                // Parameter name
    public string DisplayName { get; set; }         // Display label
    public ParameterType Type { get; set; }         // Data type
    public bool Required { get; set; }              // Is required
    public JToken? DefaultValue { get; set; }       // Default value
    public JObject? Options { get; set; }           // Type-specific options
}

public enum ParameterType
{
    String = 0,
    Number = 1,
    Date = 2,
    DateRange = 3,
    Boolean = 4,
    Select = 5,      // Dropdown
    MultiSelect = 6  // Multi-select
}
```

#### ReportInstance
Represents a generated report:

```csharp
public class ReportInstance : IAppEntity
{
    // Standard IAppEntity properties...
    
    // Generation metadata
    public DateTime GeneratedAt { get; set; }        // Generation time
    public TimeSpan GenerationTime { get; set; }     // Processing time
    public string GeneratedBy { get; set; }          // User or system
    
    // Parameters used
    public JObject Parameters { get; set; }          // Parameter values
    public DateTime? DataAsOf { get; set; }          // Data timestamp
    
    // Output
    public ReportOutputFormat Format { get; set; }   // Output format
    public string? OutputPath { get; set; }          // File location
    public byte[]? OutputData { get; set; }          // Inline data
    public long OutputSize { get; set; }             // File size
    
    // Status
    public ReportStatus Status { get; set; }         // Generation status
    public string? ErrorMessage { get; set; }        // Error details
    
    // Distribution
    public List<ReportDistribution> Distributions { get; set; } = new();
    public bool IsPublic { get; set; }              // Public access
    public DateTime? ExpiresAt { get; set; }         // Expiration
}

public enum ReportStatus
{
    Pending = 0,     // Queued
    Generating = 1,  // In progress
    Completed = 2,   // Success
    Failed = 3,      // Error
    Expired = 4      // Expired
}

public enum ReportOutputFormat
{
    HTML = 0,
    PDF = 1,
    Excel = 2,
    CSV = 3,
    JSON = 4,
    XML = 5
}

public class ReportDistribution
{
    public DistributionType Type { get; set; }      // Distribution method
    public string Recipient { get; set; }           // Recipient identifier
    public DateTime SentAt { get; set; }            // When sent
    public bool Delivered { get; set; }             // Delivery status
}

public enum DistributionType
{
    Email = 0,
    FileShare = 1,
    API = 2,
    Dashboard = 3
}
```

#### ChartSpec
Defines chart visualizations within reports:

```csharp
public class ChartSpec
{
    public string ChartId { get; set; }             // Unique identifier
    public ChartType Type { get; set; }             // Chart type
    public string DataSource { get; set; }          // Data source name
    
    // Data mapping
    public string? XAxis { get; set; }              // X-axis field
    public List<string> YAxis { get; set; } = new(); // Y-axis fields
    public string? GroupBy { get; set; }            // Series grouping
    
    // Appearance
    public string Title { get; set; }               // Chart title
    public ChartOptions Options { get; set; }       // Chart options
    public Dictionary<string, string> Colors { get; set; } = new();
    
    // Layout
    public int Width { get; set; } = 100;           // Width percentage
    public int Height { get; set; } = 400;          // Height pixels
}

public enum ChartType
{
    Line = 0,
    Bar = 1,
    Pie = 2,
    Area = 3,
    Scatter = 4,
    Heatmap = 5,
    Gauge = 6,
    Table = 7
}

public class ChartOptions
{
    public bool ShowLegend { get; set; } = true;
    public bool ShowTooltips { get; set; } = true;
    public bool Stacked { get; set; }
    public bool ShowDataLabels { get; set; }
    public string? NumberFormat { get; set; }
    public JObject? CustomOptions { get; set; }     // Chart library options
}
```

### Report Services

#### ReportLogic
Primary service for report operations:

```csharp
public class ReportLogic
{
    // Generate report
    public async Task<ReportInstance> GenerateReport(
        Guid currentUser,
        string templateName,
        JObject parameters,
        ReportOutputFormat format = ReportOutputFormat.PDF,
        GenerationOptions? options = null)
    {
        var template = await LoadReportTemplate(templateName);
        
        // Validate parameters
        ValidateParameters(template, parameters);
        
        // Check permissions
        if (!await CanGenerateReport(currentUser, template))
        {
            throw new UnauthorizedException("Cannot generate this report");
        }
        
        // Create report instance
        var instance = new ReportInstance
        {
            Template = templateName,
            Creator = currentUser,
            GeneratedAt = DateTime.UtcNow,
            GeneratedBy = "user",
            Parameters = parameters,
            Format = format,
            Status = ReportStatus.Pending
        };
        
        using (var tc = await _reportRepo.OpenTransactionAsync())
        {
            await _reportRepo.CreateAsync(tc, instance);
            
            // Queue generation
            await QueueReportGeneration(tc, instance.Id, options);
            
            await tc.CommitAsync();
        }
        
        // Generate immediately if requested
        if (options?.GenerateImmediately == true)
        {
            await ProcessReportGeneration(instance.Id);
        }
        
        return instance;
    }
    
    // Process report generation
    private async Task ProcessReportGeneration(Guid reportId)
    {
        var instance = await LoadReportInstance(reportId);
        var template = await LoadReportTemplate(instance.Template);
        
        try
        {
            var stopwatch = Stopwatch.StartNew();
            
            // Update status
            instance.Status = ReportStatus.Generating;
            await _reportRepo.UpdateAsync(instance);
            
            // Load data
            var dataSets = await LoadReportData(template, instance.Parameters);
            
            // Generate report
            var output = await GenerateReportOutput(
                template, 
                dataSets, 
                instance.Parameters,
                instance.Format);
                
            // Store output
            if (output.Data.Length > _options.MaxInlineSize)
            {
                // Store as file
                var path = await StoreReportFile(instance.Id, output);
                instance.OutputPath = path;
            }
            else
            {
                // Store inline
                instance.OutputData = output.Data;
            }
            
            instance.OutputSize = output.Data.Length;
            instance.Status = ReportStatus.Completed;
            instance.GenerationTime = stopwatch.Elapsed;
            instance.DataAsOf = DateTime.UtcNow;
            
            await _reportRepo.UpdateAsync(instance);
            
            // Distribute if configured
            if (template.Schedules.Any())
            {
                await DistributeReport(instance, template);
            }
        }
        catch (Exception ex)
        {
            instance.Status = ReportStatus.Failed;
            instance.ErrorMessage = ex.Message;
            await _reportRepo.UpdateAsync(instance);
            throw;
        }
    }
    
    // Load report data
    private async Task<Dictionary<string, DataSet>> LoadReportData(
        ReportTemplate template,
        JObject parameters)
    {
        var dataSets = new Dictionary<string, DataSet>();
        
        foreach (var source in template.DataSources)
        {
            var data = await LoadDataSource(source, parameters);
            dataSets[source.Name] = data;
        }
        
        return dataSets;
    }
    
    // Load individual data source
    private async Task<DataSet> LoadDataSource(
        ReportDataSource source,
        JObject parameters)
    {
        switch (source.Type)
        {
            case DataSourceType.Table:
                return await LoadTableData(source, parameters);
                
            case DataSourceType.Entity:
                return await LoadEntityData(source, parameters);
                
            case DataSourceType.Query:
                return await LoadQueryData(source, parameters);
                
            case DataSourceType.KPI:
                return await LoadKPIData(source, parameters);
                
            case DataSourceType.Aggregation:
                return await LoadAggregatedData(source, parameters);
                
            default:
                throw new NotSupportedException($"Data source type {source.Type} not supported");
        }
    }
}
```

#### HTMLReportEngine
Generates HTML-based reports:

```csharp
public class HTMLReportEngine
{
    private readonly ITemplateEngine _templateEngine;
    private readonly IChartRenderer _chartRenderer;
    
    public async Task<ReportOutput> GenerateReport(
        ReportTemplate template,
        Dictionary<string, DataSet> dataSets,
        JObject parameters,
        ReportOutputFormat format)
    {
        // Render HTML
        var html = await RenderHTML(template, dataSets, parameters);
        
        // Convert to requested format
        switch (format)
        {
            case ReportOutputFormat.HTML:
                return new ReportOutput
                {
                    Data = Encoding.UTF8.GetBytes(html),
                    ContentType = "text/html"
                };
                
            case ReportOutputFormat.PDF:
                return await ConvertToPDF(html, template);
                
            case ReportOutputFormat.Excel:
                return await ConvertToExcel(dataSets, template);
                
            default:
                throw new NotSupportedException($"Format {format} not supported");
        }
    }
    
    private async Task<string> RenderHTML(
        ReportTemplate template,
        Dictionary<string, DataSet> dataSets,
        JObject parameters)
    {
        // Prepare template context
        var context = new TemplateContext
        {
            Title = template.Title,
            Parameters = parameters,
            DataSets = dataSets,
            GeneratedAt = DateTime.UtcNow
        };
        
        // Render charts
        if (template.Layout.Charts != null)
        {
            context.Charts = await RenderCharts(template.Layout.Charts, dataSets);
        }
        
        // Apply template
        var html = await _templateEngine.Render(template.TemplateHtml, context);
        
        // Inject CSS
        if (!string.IsNullOrEmpty(template.TemplateCss))
        {
            html = InjectCSS(html, template.TemplateCss);
        }
        
        return html;
    }
    
    private async Task<Dictionary<string, ChartOutput>> RenderCharts(
        List<ChartSpec> charts,
        Dictionary<string, DataSet> dataSets)
    {
        var chartOutputs = new Dictionary<string, ChartOutput>();
        
        foreach (var chart in charts)
        {
            var dataSet = dataSets[chart.DataSource];
            var output = await _chartRenderer.RenderChart(chart, dataSet);
            chartOutputs[chart.ChartId] = output;
        }
        
        return chartOutputs;
    }
}
```

### Report Rule Actions

#### RuleActionCreateReport
Creates reports from events:

```csharp
public class RuleActionCreateReport : IRuleActionEvaluator
{
    public class Args
    {
        public string ReportTemplate { get; set; }
        public JObject? Parameters { get; set; }
        public string? ParametersQuery { get; set; }
        public ReportOutputFormat Format { get; set; } = ReportOutputFormat.PDF;
        public bool GenerateImmediately { get; set; } = false;
        public List<string>? EmailTo { get; set; }
    }
    
    public async Task<JObject> EvaluateAsync(JObject args, JObject eventData)
    {
        var a = args.ToObject<Args>();
        
        // Build parameters
        var parameters = a.Parameters ?? new JObject();
        
        if (!string.IsNullOrEmpty(a.ParametersQuery))
        {
            var queryParams = JsonPathQuery(eventData, a.ParametersQuery) as JObject;
            if (queryParams != null)
            {
                parameters.Merge(queryParams);
            }
        }
        
        // Generate report
        var instance = await _reportLogic.EventGenerateReport(
            templateName: a.ReportTemplate,
            parameters: parameters,
            format: a.Format,
            options: new GenerationOptions
            {
                GenerateImmediately = a.GenerateImmediately,
                EmailTo = a.EmailTo
            });
            
        eventData[$"report_{a.ReportTemplate}_Id"] = instance.Id;
        
        return eventData;
    }
}
```

### Report Examples

#### Creating a Sales Report Template
```csharp
var salesReportTemplate = new ReportTemplate
{
    Name = "MonthlySalesReport",
    Title = "Monthly Sales Report",
    Tags = new List<string> { "sales", "monthly", "executive" },
    
    DataSources = new List<ReportDataSource>
    {
        new ReportDataSource
        {
            Name = "orders",
            Type = DataSourceType.Table,
            TableTemplate = "Orders",
            Filter = JObject.FromObject(new
            {
                OrderDate = new
                {
                    $gte = "@startDate",
                    $lt = "@endDate"
                },
                Status = new { $ne = "cancelled" }
            }),
            OrderBy = "OrderDate",
            Ascending = true
        },
        new ReportDataSource
        {
            Name = "summary",
            Type = DataSourceType.Aggregation,
            TableTemplate = "Orders",
            Filter = JObject.FromObject(new
            {
                OrderDate = new
                {
                    $gte = "@startDate",
                    $lt = "@endDate"
                }
            }),
            Aggregations = new List<AggregationDef>
            {
                new AggregationDef { Field = "OrderId", Function = AggregationFunction.Count, Alias = "orderCount" },
                new AggregationDef { Field = "TotalAmount", Function = AggregationFunction.Sum, Alias = "totalRevenue" },
                new AggregationDef { Field = "TotalAmount", Function = AggregationFunction.Average, Alias = "avgOrderValue" }
            }
        },
        new ReportDataSource
        {
            Name = "dailySales",
            Type = DataSourceType.Aggregation,
            TableTemplate = "Orders",
            GroupBy = new List<string> { "date(OrderDate)" },
            Aggregations = new List<AggregationDef>
            {
                new AggregationDef { Field = "TotalAmount", Function = AggregationFunction.Sum, Alias = "dailyRevenue" }
            }
        }
    },
    
    Layout = new ReportLayout
    {
        Sections = new List<ReportSection>
        {
            new ReportSection
            {
                Type = SectionType.Header,
                Content = @"
                    <h1>{{Title}}</h1>
                    <p>Report Period: {{formatDate Parameters.startDate}} to {{formatDate Parameters.endDate}}</p>
                    <p>Generated: {{formatDateTime GeneratedAt}}</p>
                "
            },
            new ReportSection
            {
                Type = SectionType.Summary,
                Content = @"
                    <div class='summary-box'>
                        <h2>Executive Summary</h2>
                        <div class='metrics'>
                            <div class='metric'>
                                <span class='label'>Total Orders</span>
                                <span class='value'>{{DataSets.summary.orderCount}}</span>
                            </div>
                            <div class='metric'>
                                <span class='label'>Total Revenue</span>
                                <span class='value'>${{formatNumber DataSets.summary.totalRevenue}}</span>
                            </div>
                            <div class='metric'>
                                <span class='label'>Average Order Value</span>
                                <span class='value'>${{formatNumber DataSets.summary.avgOrderValue 2}}</span>
                            </div>
                        </div>
                    </div>
                "
            },
            new ReportSection
            {
                Type = SectionType.Chart,
                ChartId = "dailySalesChart"
            },
            new ReportSection
            {
                Type = SectionType.Table,
                Content = @"
                    <h2>Order Details</h2>
                    <table class='data-table'>
                        <thead>
                            <tr>
                                <th>Order ID</th>
                                <th>Date</th>
                                <th>Customer</th>
                                <th>Items</th>
                                <th>Total</th>
                            </tr>
                        </thead>
                        <tbody>
                            {{#each DataSets.orders}}
                            <tr>
                                <td>{{OrderId}}</td>
                                <td>{{formatDate OrderDate}}</td>
                                <td>{{CustomerName}}</td>
                                <td>{{ItemCount}}</td>
                                <td>${{formatNumber TotalAmount}}</td>
                            </tr>
                            {{/each}}
                        </tbody>
                    </table>
                "
            }
        },
        
        Charts = new List<ChartSpec>
        {
            new ChartSpec
            {
                ChartId = "dailySalesChart",
                Type = ChartType.Line,
                DataSource = "dailySales",
                Title = "Daily Sales Trend",
                XAxis = "date",
                YAxis = new List<string> { "dailyRevenue" },
                Options = new ChartOptions
                {
                    ShowDataLabels = false,
                    NumberFormat = "$#,##0"
                }
            }
        }
    },
    
    TemplateCss = @"
        .summary-box { background: #f5f5f5; padding: 20px; margin: 20px 0; }
        .metrics { display: flex; justify-content: space-around; }
        .metric { text-align: center; }
        .metric .label { display: block; font-size: 14px; color: #666; }
        .metric .value { display: block; font-size: 24px; font-weight: bold; color: #333; }
        .data-table { width: 100%; border-collapse: collapse; }
        .data-table th, .data-table td { padding: 8px; border: 1px solid #ddd; }
        .data-table th { background: #f0f0f0; font-weight: bold; }
    ",
    
    Parameters = new List<ReportParameter>
    {
        new ReportParameter
        {
            Name = "startDate",
            DisplayName = "Start Date",
            Type = ParameterType.Date,
            Required = true,
            DefaultValue = JToken.FromObject("firstDayOfMonth()")
        },
        new ReportParameter
        {
            Name = "endDate",
            DisplayName = "End Date",
            Type = ParameterType.Date,
            Required = true,
            DefaultValue = JToken.FromObject("today()")
        }
    },
    
    SupportedFormats = new List<ReportOutputFormat>
    {
        ReportOutputFormat.PDF,
        ReportOutputFormat.Excel,
        ReportOutputFormat.HTML
    },
    
    DefaultOrientation = ReportOrientation.Portrait,
    PageSize = "Letter",
    
    Schedules = new List<ScheduledEventTemplate>
    {
        new ScheduledEventTemplate
        {
            Name = "MonthlyGeneration",
            Schedule = "0 0 1 * *",  // First day of month
            Topic = "GenerateMonthlyReport"
        }
    },
    
    IsVisibleToUsers = true,
    AllowedRoles = new List<string> { "Manager", "Executive" },
    CacheMinutes = 60
};
```

#### Implementing a Dashboard Report Service
```csharp
public class DashboardReportService
{
    // Generate dashboard reports
    public async Task<DashboardReportResult> GenerateDashboardReports(
        Guid userId,
        Guid workSetId,
        DateRange period)
    {
        var result = new DashboardReportResult();
        
        // Load user's dashboard configuration
        var dashboardConfig = await LoadDashboardConfig(userId, workSetId);
        
        // Generate each widget report
        var tasks = dashboardConfig.Widgets.Select(async widget =>
        {
            try
            {
                var reportInstance = await GenerateWidgetReport(
                    widget,
                    period,
                    userId,
                    workSetId);
                    
                return new WidgetReportResult
                {
                    WidgetId = widget.Id,
                    Success = true,
                    ReportInstance = reportInstance
                };
            }
            catch (Exception ex)
            {
                return new WidgetReportResult
                {
                    WidgetId = widget.Id,
                    Success = false,
                    Error = ex.Message
                };
            }
        });
        
        result.WidgetReports = await Task.WhenAll(tasks);
        result.GeneratedAt = DateTime.UtcNow;
        
        return result;
    }
    
    private async Task<ReportInstance> GenerateWidgetReport(
        DashboardWidget widget,
        DateRange period,
        Guid userId,
        Guid workSetId)
    {
        // Build parameters
        var parameters = new JObject
        {
            ["startDate"] = period.Start,
            ["endDate"] = period.End,
            ["userId"] = userId,
            ["workSetId"] = workSetId
        };
        
        // Add widget-specific parameters
        if (widget.Parameters != null)
        {
            parameters.Merge(widget.Parameters);
        }
        
        // Generate report
        return await _reportLogic.GenerateReport(
            currentUser: userId,
            templateName: widget.ReportTemplate,
            parameters: parameters,
            format: ReportOutputFormat.JSON, // JSON for dashboard
            options: new GenerationOptions
            {
                GenerateImmediately = true,
                CacheKey = $"dashboard_{widget.Id}_{period.GetHashCode()}"
            });
    }
}
```

#### Creating a Compliance Report
```csharp
public class ComplianceReportTemplate
{
    public static ReportTemplate CreateAuditLogReport()
    {
        return new ReportTemplate
        {
            Name = "AuditLogReport",
            Title = "System Audit Log Report",
            Tags = new List<string> { "compliance", "audit", "security" },
            
            DataSources = new List<ReportDataSource>
            {
                new ReportDataSource
                {
                    Name = "auditEvents",
                    Type = DataSourceType.Table,
                    TableTemplate = "AuditLog",
                    Filter = JObject.FromObject(new
                    {
                        Timestamp = new
                        {
                            $gte = "@startDate",
                            $lt = "@endDate"
                        },
                        EventType = "@eventType"  // Optional filter
                    }),
                    OrderBy = "Timestamp",
                    Ascending = false,
                    MaxRows = 10000
                },
                new ReportDataSource
                {
                    Name = "userActivity",
                    Type = DataSourceType.Aggregation,
                    TableTemplate = "AuditLog",
                    GroupBy = new List<string> { "UserId", "UserName" },
                    Aggregations = new List<AggregationDef>
                    {
                        new AggregationDef { Field = "EventId", Function = AggregationFunction.Count, Alias = "eventCount" }
                    }
                },
                new ReportDataSource
                {
                    Name = "eventTypes",
                    Type = DataSourceType.Aggregation,
                    TableTemplate = "AuditLog",
                    GroupBy = new List<string> { "EventType" },
                    Aggregations = new List<AggregationDef>
                    {
                        new AggregationDef { Field = "EventId", Function = AggregationFunction.Count, Alias = "count" }
                    }
                }
            },
            
            Parameters = new List<ReportParameter>
            {
                new ReportParameter
                {
                    Name = "startDate",
                    DisplayName = "Start Date",
                    Type = ParameterType.Date,
                    Required = true
                },
                new ReportParameter
                {
                    Name = "endDate",
                    DisplayName = "End Date",
                    Type = ParameterType.Date,
                    Required = true
                },
                new ReportParameter
                {
                    Name = "eventType",
                    DisplayName = "Event Type",
                    Type = ParameterType.Select,
                    Required = false,
                    Options = JObject.FromObject(new
                    {
                        choices = new[]
                        {
                            new { value = "", label = "All Events" },
                            new { value = "Login", label = "Login" },
                            new { value = "Logout", label = "Logout" },
                            new { value = "Create", label = "Create" },
                            new { value = "Update", label = "Update" },
                            new { value = "Delete", label = "Delete" },
                            new { value = "Export", label = "Export" },
                            new { value = "Permission", label = "Permission Change" }
                        }
                    })
                }
            },
            
            // Compliance features
            SupportedFormats = new List<ReportOutputFormat>
            {
                ReportOutputFormat.PDF,  // For archival
                ReportOutputFormat.CSV   // For analysis
            },
            
            // Restricted access
            IsVisibleToUsers = false,
            AllowedRoles = new List<string> { "Auditor", "Administrator" }
        };
    }
}
```

### Best Practices

1. **Design reusable templates** - Create parameterized templates for flexibility
2. **Optimize data queries** - Use aggregations and limits to manage data volume
3. **Cache frequently used reports** - Reduce generation overhead
4. **Implement access controls** - Ensure data security and compliance
5. **Version report templates** - Track changes to report definitions
6. **Handle large datasets** - Implement pagination and streaming
7. **Provide multiple formats** - Support various output requirements
8. **Schedule off-peak generation** - Reduce system load
9. **Monitor report performance** - Track generation times and resource usage
10. **Archive historical reports** - Maintain audit trail and compliance

---

## Comments System

The Comments System provides threaded discussion capabilities for any entity in the platform. It supports nested replies, mentions, attachments, moderation, and real-time notifications.

### Core Components

#### Comment
The primary comment entity:

```csharp
public class Comment : IDataModel
{
    public Guid Id { get; set; }
    public int Version { get; set; }
    
    // Entity reference
    public string EntityType { get; set; }          // Entity type
    public Guid EntityId { get; set; }              // Entity ID
    public string? EntityTemplate { get; set; }      // Entity template
    
    // Content
    public string Text { get; set; }                // Comment text
    public string? FormattedText { get; set; }      // HTML formatted
    public List<string> Mentions { get; set; } = new(); // @mentions
    public List<AttachmentReference> Attachments { get; set; } = new();
    
    // Threading
    public Guid? ParentCommentId { get; set; }      // Parent for replies
    public int NestingLevel { get; set; }           // Reply depth
    public string ThreadPath { get; set; }          // Hierarchical path
    
    // Metadata
    public Guid Author { get; set; }                // Comment author
    public DateTime CreatedAt { get; set; }         // Creation time
    public DateTime? EditedAt { get; set; }         // Last edit time
    public bool IsEdited { get; set; }              // Edit flag
    
    // Status
    public CommentStatus Status { get; set; }       // Comment status
    public bool IsDeleted { get; set; }             // Soft delete
    public DateTime? DeletedAt { get; set; }        // Deletion time
    public Guid? DeletedBy { get; set; }            // Who deleted
    
    // Moderation
    public bool IsFlagged { get; set; }             // Flagged for review
    public int FlagCount { get; set; }              // Number of flags
    public List<CommentFlag> Flags { get; set; } = new();
    public ModerationStatus? ModerationStatus { get; set; }
    
    // Engagement
    public int LikeCount { get; set; }              // Number of likes
    public List<Guid> LikedBy { get; set; } = new(); // Users who liked
    public int ReplyCount { get; set; }             // Direct replies
    
    // Permissions
    public bool AllowReplies { get; set; } = true;  // Can be replied to
    public bool AllowEditing { get; set; } = true;  // Can be edited
}

public enum CommentStatus
{
    Active = 0,      // Normal state
    Hidden = 1,      // Hidden by moderation
    Pending = 2,     // Awaiting moderation
    Locked = 3       // No further interaction
}

public enum ModerationStatus
{
    Approved = 0,
    Rejected = 1,
    Pending = 2,
    AutoApproved = 3
}

public class CommentFlag
{
    public Guid UserId { get; set; }               // Who flagged
    public DateTime FlaggedAt { get; set; }         // When flagged
    public FlagReason Reason { get; set; }          // Why flagged
    public string? Details { get; set; }            // Additional info
}

public enum FlagReason
{
    Spam = 0,
    Inappropriate = 1,
    Offensive = 2,
    Misinformation = 3,
    Other = 4
}
```

### Comment Services

#### CommentsLogic
Primary service for comment operations:

```csharp
public class CommentsLogic
{
    // Add comment
    public async Task<Comment> AddComment(
        Guid currentUser,
        string entityType,
        Guid entityId,
        string text,
        Guid? parentCommentId = null,
        List<ManagedFileAction>? attachments = null)
    {
        // Validate entity exists and user has access
        await ValidateEntityAccess(currentUser, entityType, entityId);
        
        // Check if comments are allowed
        var template = await GetEntityTemplate(entityType, entityId);
        if (!template.AllowComments)
        {
            throw new InvalidOperationException("Comments not allowed for this entity");
        }
        
        // Process text
        var processedText = await ProcessCommentText(text);
        
        Comment comment;
        
        using (var tc = await _commentRepo.OpenTransactionAsync())
        {
            // Create comment
            comment = new Comment
            {
                EntityType = entityType,
                EntityId = entityId,
                EntityTemplate = template.Name,
                Text = processedText.Text,
                FormattedText = processedText.FormattedHtml,
                Mentions = processedText.Mentions,
                Author = currentUser,
                CreatedAt = DateTime.UtcNow,
                Status = CommentStatus.Active
            };
            
            // Handle threading
            if (parentCommentId.HasValue)
            {
                var parent = await LoadComment(tc, parentCommentId.Value);
                
                if (!parent.AllowReplies)
                {
                    throw new InvalidOperationException("Replies not allowed for this comment");
                }
                
                comment.ParentCommentId = parentCommentId;
                comment.NestingLevel = Math.Min(parent.NestingLevel + 1, _options.MaxNestingLevel);
                comment.ThreadPath = $"{parent.ThreadPath}/{comment.Id}";
                
                // Update parent reply count
                parent.ReplyCount++;
                await _commentRepo.UpdateAsync(tc, parent);
            }
            else
            {
                comment.NestingLevel = 0;
                comment.ThreadPath = comment.Id.ToString();
            }
            
            // Apply moderation
            comment.ModerationStatus = await ApplyModeration(comment, currentUser);
            if (comment.ModerationStatus == ModerationStatus.Rejected)
            {
                comment.Status = CommentStatus.Hidden;
            }
            
            // Handle attachments
            if (attachments != null && attachments.Any())
            {
                comment.Attachments = await ProcessAttachments(tc, attachments, currentUser);
            }
            
            await _commentRepo.CreateAsync(tc, comment);
            
            // Send notifications
            await SendCommentNotifications(tc, comment);
            
            // Generate event
            await _eventSink.SinkAsync(tc, new AppEvent
            {
                Topic = "Comment.Created",
                OriginEntityType = "Comment",
                OriginId = comment.Id,
                EntityPayload = comment.ToBsonDocument()
            });
            
            await tc.CommitAsync();
        }
        
        return comment;
    }
    
    // Edit comment
    public async Task<Comment> EditComment(
        Guid currentUser,
        Guid commentId,
        string newText)
    {
        var comment = await LoadComment(commentId);
        
        // Check permissions
        if (comment.Author != currentUser && !await IsModeratorAsync(currentUser))
        {
            throw new UnauthorizedException("Cannot edit this comment");
        }
        
        if (!comment.AllowEditing || comment.Status != CommentStatus.Active)
        {
            throw new InvalidOperationException("Comment cannot be edited");
        }
        
        // Check edit time limit
        if (_options.EditTimeLimit.HasValue && 
            DateTime.UtcNow - comment.CreatedAt > _options.EditTimeLimit.Value)
        {
            throw new InvalidOperationException("Edit time limit exceeded");
        }
        
        // Process new text
        var processedText = await ProcessCommentText(newText);
        
        using (var tc = await _commentRepo.OpenTransactionAsync())
        {
            comment.Text = processedText.Text;
            comment.FormattedText = processedText.FormattedHtml;
            comment.Mentions = processedText.Mentions;
            comment.IsEdited = true;
            comment.EditedAt = DateTime.UtcNow;
            
            await _commentRepo.UpdateAsync(tc, comment);
            
            // Notify mentioned users
            await NotifyNewMentions(tc, comment, processedText.Mentions);
            
            await tc.CommitAsync();
        }
        
        return comment;
    }
    
    // Get comments for entity
    public async Task<CommentThreadViewModel> GetEntityComments(
        Guid currentUser,
        string entityType,
        Guid entityId,
        CommentQueryOptions? options = null)
    {
        // Validate access
        await ValidateEntityAccess(currentUser, entityType, entityId);
        
        options ??= new CommentQueryOptions();
        
        // Load comments
        var (comments, _) = await _commentRepo.GetAsync(
            c => c.EntityType == entityType && 
                 c.EntityId == entityId &&
                 !c.IsDeleted &&
                 (c.Status == CommentStatus.Active || 
                  await IsModeratorAsync(currentUser)));
                  
        // Build thread structure
        var rootComments = comments
            .Where(c => !c.ParentCommentId.HasValue)
            .OrderBy(c => GetSortValue(c, options.SortBy))
            .Skip(options.Skip)
            .Take(options.Take)
            .ToList();
            
        var thread = new CommentThreadViewModel
        {
            EntityType = entityType,
            EntityId = entityId,
            TotalComments = comments.Count,
            Comments = new List<CommentViewModel>()
        };
        
        // Build comment tree
        foreach (var root in rootComments)
        {
            var commentVm = await BuildCommentViewModel(root, comments, currentUser);
            thread.Comments.Add(commentVm);
        }
        
        return thread;
    }
    
    // Like/unlike comment
    public async Task<Comment> ToggleLike(
        Guid currentUser,
        Guid commentId)
    {
        var comment = await LoadComment(commentId);
        
        using (var tc = await _commentRepo.OpenTransactionAsync())
        {
            if (comment.LikedBy.Contains(currentUser))
            {
                // Unlike
                comment.LikedBy.Remove(currentUser);
                comment.LikeCount--;
            }
            else
            {
                // Like
                comment.LikedBy.Add(currentUser);
                comment.LikeCount++;
                
                // Notify author
                if (comment.Author != currentUser)
                {
                    await NotifyCommentLiked(tc, comment, currentUser);
                }
            }
            
            await _commentRepo.UpdateAsync(tc, comment);
            await tc.CommitAsync();
        }
        
        return comment;
    }
    
    // Process comment text
    private async Task<ProcessedText> ProcessCommentText(string text)
    {
        var result = new ProcessedText { Text = text };
        
        // Extract mentions
        var mentionRegex = new Regex(@"@(\w+)");
        var mentions = mentionRegex.Matches(text);
        
        foreach (Match match in mentions)
        {
            var username = match.Groups[1].Value;
            var user = await _userService.FindByUsername(username);
            
            if (user != null)
            {
                result.Mentions.Add(username);
            }
        }
        
        // Convert to HTML (markdown, mentions, etc.)
        result.FormattedHtml = await _formatter.FormatComment(text);
        
        return result;
    }
}
```

### Comment Rule Actions

#### RuleActionCommentCreate
Creates comments from events:

```csharp
public class RuleActionCommentCreate : IRuleActionEvaluator
{
    public class Args
    {
        public string? EntityTypeQuery { get; set; }
        public string? EntityIdQuery { get; set; }
        public string? Text { get; set; }
        public string? TextQuery { get; set; }
        public string? AuthorQuery { get; set; }
        public bool SystemComment { get; set; } = false;
    }
    
    public async Task<JObject> EvaluateAsync(JObject args, JObject eventData)
    {
        var a = args.ToObject<Args>();
        
        // Resolve parameters
        var entityType = ResolveString(eventData, a.EntityTypeQuery) ?? 
            eventData["OriginEntityType"]?.ToString();
        var entityId = ResolveGuid(eventData, a.EntityIdQuery) ?? 
            Guid.Parse(eventData["OriginId"].ToString());
        var text = a.Text ?? ResolveString(eventData, a.TextQuery);
        var author = ResolveGuid(eventData, a.AuthorQuery) ?? 
            (a.SystemComment ? Guid.Empty : throw new InvalidOperationException("Author required"));
            
        // Create comment
        var comment = await _commentsLogic.EventCreateComment(
            entityType: entityType,
            entityId: entityId.Value,
            text: text,
            author: author.Value,
            isSystem: a.SystemComment);
            
        eventData["createdCommentId"] = comment.Id;
        
        return eventData;
    }
}
```

### Comment Examples

#### Implementing a Discussion Forum
```csharp
public class ForumService
{
    // Create forum post with initial comment
    public async Task<ForumPostResult> CreateForumPost(
        Guid userId,
        string title,
        string content,
        string[] tags,
        Guid forumId)
    {
        using (var tc = await _workItemRepo.OpenTransactionAsync())
        {
            // Create forum post as work item
            var post = await _workItemLogic.CreateWorkItem(
                tc,
                currentUser: userId,
                templateName: "ForumPost",
                workSet: forumId,
                title: title,
                description: content.Substring(0, Math.Min(200, content.Length)) + "...",
                creationData: new WorkItemCreationData
                {
                    Tags = tags,
                    Metadata = JObject.FromObject(new
                    {
                        viewCount = 0,
                        lastActivity = DateTime.UtcNow,
                        isPinned = false,
                        isLocked = false
                    })
                });
                
            // Add content as first comment
            var comment = await _commentsLogic.AddComment(
                tc,
                currentUser: userId,
                entityType: "WorkItem",
                entityId: post.Id,
                text: content);
                
            await tc.CommitAsync();
            
            return new ForumPostResult
            {
                PostId = post.Id,
                CommentId = comment.Id,
                ForumId = forumId
            };
        }
    }
    
    // Get forum thread with pagination
    public async Task<ForumThreadViewModel> GetForumThread(
        Guid userId,
        Guid postId,
        int page = 1,
        int pageSize = 20)
    {
        var post = await _workItemLogic.LoadWorkItem(postId);
        
        // Update view count
        await IncrementViewCount(postId);
        
        // Get comments
        var comments = await _commentsLogic.GetEntityComments(
            currentUser: userId,
            entityType: "WorkItem",
            entityId: postId,
            options: new CommentQueryOptions
            {
                Skip = (page - 1) * pageSize,
                Take = pageSize,
                SortBy = CommentSortBy.Chronological,
                IncludeDeleted = false
            });
            
        return new ForumThreadViewModel
        {
            Post = BuildPostViewModel(post),
            Comments = comments,
            CurrentPage = page,
            TotalPages = (int)Math.Ceiling(comments.TotalComments / (double)pageSize)
        };
    }
}
```

#### Implementing Comment Moderation
```csharp
public class CommentModerationService
{
    // Auto-moderation rules
    public async Task<ModerationStatus> ApplyAutoModeration(
        Comment comment,
        Guid authorId)
    {
        var author = await _userService.GetUser(authorId);
        
        // New user check
        if (author.CreatedDate > DateTime.UtcNow.AddDays(-7))
        {
            // Check for spam patterns
            if (await IsLikelySpam(comment.Text))
            {
                return ModerationStatus.Rejected;
            }
            
            // Require moderation for links
            if (ContainsLinks(comment.Text))
            {
                return ModerationStatus.Pending;
            }
        }
        
        // Trusted user - auto approve
        if (author.Tags.Contains("trusted"))
        {
            return ModerationStatus.AutoApproved;
        }
        
        // Check banned words
        if (await ContainsBannedWords(comment.Text))
        {
            return ModerationStatus.Pending;
        }
        
        return ModerationStatus.Approved;
    }
    
    // Manual moderation queue
    public async Task<ModerationQueueViewModel> GetModerationQueue(
        Guid moderatorId,
        ModerationFilter filter)
    {
        // Verify moderator role
        if (!await IsModerator(moderatorId))
        {
            throw new UnauthorizedException("Not a moderator");
        }
        
        // Build query
        Expression<Func<Comment, bool>> predicate = c => 
            c.ModerationStatus == ModerationStatus.Pending ||
            c.IsFlagged;
            
        if (filter.EntityType != null)
        {
            predicate = predicate.And(c => c.EntityType == filter.EntityType);
        }
        
        if (filter.DateFrom.HasValue)
        {
            predicate = predicate.And(c => c.CreatedAt >= filter.DateFrom.Value);
        }
        
        // Load comments
        var (comments, _) = await _commentRepo.GetOrderedAsync(
            predicate,
            c => c.FlagCount,
            ascending: false);
            
        return new ModerationQueueViewModel
        {
            Comments = comments.Select(c => BuildModerationView(c)).ToList(),
            TotalCount = comments.Count,
            Filter = filter
        };
    }
    
    // Moderate comment
    public async Task ModerateComment(
        Guid moderatorId,
        Guid commentId,
        ModerationAction action,
        string? reason = null)
    {
        var comment = await LoadComment(commentId);
        
        using (var tc = await _commentRepo.OpenTransactionAsync())
        {
            switch (action)
            {
                case ModerationAction.Approve:
                    comment.ModerationStatus = ModerationStatus.Approved;
                    comment.Status = CommentStatus.Active;
                    comment.IsFlagged = false;
                    break;
                    
                case ModerationAction.Reject:
                    comment.ModerationStatus = ModerationStatus.Rejected;
                    comment.Status = CommentStatus.Hidden;
                    break;
                    
                case ModerationAction.Delete:
                    comment.IsDeleted = true;
                    comment.DeletedAt = DateTime.UtcNow;
                    comment.DeletedBy = moderatorId;
                    comment.Status = CommentStatus.Hidden;
                    break;
                    
                case ModerationAction.Lock:
                    comment.Status = CommentStatus.Locked;
                    comment.AllowReplies = false;
                    comment.AllowEditing = false;
                    break;
            }
            
            await _commentRepo.UpdateAsync(tc, comment);
            
            // Log moderation action
            await LogModerationAction(tc, comment, moderatorId, action, reason);
            
            // Notify author if rejected
            if (action == ModerationAction.Reject || action == ModerationAction.Delete)
            {
                await NotifyCommentModerated(tc, comment, action, reason);
            }
            
            await tc.CommitAsync();
        }
    }
}
```

### Best Practices

1. **Implement rate limiting** - Prevent comment spam and abuse
2. **Use threading wisely** - Limit nesting depth for readability
3. **Process mentions** - Notify mentioned users appropriately
4. **Handle moderation** - Balance automation with manual review
5. **Support rich formatting** - Allow markdown or limited HTML
6. **Enable real-time updates** - Use SignalR or polling for live comments
7. **Implement edit history** - Track changes for transparency
8. **Cache comment counts** - Avoid expensive queries
9. **Handle deleted comments** - Show placeholders in threads
10. **Respect privacy** - Allow users to delete their own comments

---

## Content System

The Content System provides a unified content management framework that handles templates, schemas, and configuration data across all platform components. It supports file-based content, JSON schemas, localization, and version control.

### Core Components

#### IApplicationPlatformContent
The central interface for content management:

```csharp
public interface IApplicationPlatformContent
{
    // Template management
    Task<T?> GetContentTypeAsync<T>(string name) where T : class, IContentType;
    Task<List<T>> GetAllContentTypesAsync<T>() where T : class, IContentType;
    Task SaveContentTypeAsync<T>(T contentType) where T : class, IContentType;
    Task DeleteContentTypeAsync<T>(string name) where T : class, IContentType;
    
    // JSON Schema support
    Task<JSchema?> GetJsonSchemaAsync(string name);
    Task<bool> ValidateAgainstSchemaAsync(string schemaName, JObject data);
    
    // Content domains
    Task<ContentDomain?> GetContentDomainAsync(string name);
    Task<List<ContentDomain>> GetAllContentDomainsAsync();
    
    // Satellite content
    Task<SatelliteJson?> GetSatelliteContentAsync(string name);
    Task<Dictionary<string, object>> GetAllSatelliteContentAsync();
    
    // Localization
    Task<string?> GetLocalizedStringAsync(string key, string? culture = null);
    Task<Dictionary<string, string>> GetAllLocalizedStringsAsync(string culture);
    
    // Events
    event EventHandler<ContentChangedEventArgs> ContentChanged;
}
```

#### IContentType
Base interface for all content types:

```csharp
public interface IContentType
{
    string Name { get; set; }               // Unique identifier
    string Title { get; set; }              // Display name
    List<string> Tags { get; set; }         // Categorization tags
}
```

#### ContentDomain
Represents a logical grouping of content:

```csharp
public class ContentDomain
{
    public string Name { get; set; }                // Domain name
    public string Title { get; set; }               // Display title
    public string? Description { get; set; }         // Description
    public List<string> Tags { get; set; } = new(); // Tags
    
    // Content organization
    public List<ContentElement> Elements { get; set; } = new();
    public Dictionary<string, object> Metadata { get; set; } = new();
    
    // Schema validation
    public string? SchemaName { get; set; }         // Associated schema
    public bool ValidateContent { get; set; }       // Enable validation
    
    // Access control
    public List<string> AllowedRoles { get; set; } = new();
    public bool IsPublic { get; set; }              // Public access
    
    // Versioning
    public string Version { get; set; } = "1.0";    // Content version
    public DateTime LastModified { get; set; }      // Last update
    public string? ModifiedBy { get; set; }         // Who modified
}
```

#### ContentElement
Individual content item within a domain:

```csharp
public class ContentElement
{
    public string Key { get; set; }                // Element key
    public string? Title { get; set; }              // Display title
    public ContentElementType Type { get; set; }    // Element type
    public JToken Value { get; set; }               // Content value
    
    // Metadata
    public Dictionary<string, object> Attributes { get; set; } = new();
    public List<string> Tags { get; set; } = new();
    
    // Localization
    public Dictionary<string, JToken> Localizations { get; set; } = new();
    
    // Validation
    public string? SchemaRef { get; set; }          // Schema reference
    public bool IsRequired { get; set; }            // Required element
    
    // Lifecycle
    public DateTime CreatedAt { get; set; }         // Creation time
    public DateTime UpdatedAt { get; set; }         // Last update
    public bool IsActive { get; set; } = true;      // Active status
}

public enum ContentElementType
{
    String = 0,      // Text content
    Number = 1,      // Numeric value
    Boolean = 2,     // Boolean flag
    Object = 3,      // JSON object
    Array = 4,       // JSON array
    Reference = 5,   // Reference to other content
    Template = 6,    // Template content
    Schema = 7       // JSON schema
}
```

#### SatelliteJson
External JSON content reference:

```csharp
public class SatelliteJson
{
    public string Name { get; set; }                // Satellite name
    public string FilePath { get; set; }            // File path
    public JObject Content { get; set; }            // Parsed content
    
    // Metadata
    public DateTime LastLoaded { get; set; }        // Last load time
    public long FileSize { get; set; }              // File size
    public string ContentHash { get; set; }         // Content hash
    
    // Configuration
    public bool WatchForChanges { get; set; }       // Auto-reload
    public TimeSpan? RefreshInterval { get; set; }  // Refresh frequency
    public bool CacheContent { get; set; }          // Cache in memory
    
    // Validation
    public string? SchemaFile { get; set; }         // Validation schema
    public bool ValidateOnLoad { get; set; }        // Validate content
}
```

### Content Services

#### FileApplicationPlatformContent
File-based content implementation:

```csharp
public class FileApplicationPlatformContent : IApplicationPlatformContent
{
    private readonly FileApplicationPlatformContentOptions _options;
    private readonly ILogger<FileApplicationPlatformContent> _logger;
    private readonly ConcurrentDictionary<string, object> _cache = new();
    private readonly FileSystemWatcher _watcher;
    
    public FileApplicationPlatformContent(
        IOptions<FileApplicationPlatformContentOptions> options,
        ILogger<FileApplicationPlatformContent> logger)
    {
        _options = options.Value;
        _logger = logger;
        
        // Setup file watcher
        if (_options.WatchForChanges)
        {
            _watcher = new FileSystemWatcher(_options.ContentPath)
            {
                Filter = "*.json",
                NotifyFilter = NotifyFilters.LastWrite | NotifyFilters.CreationTime,
                EnableRaisingEvents = true
            };
            
            _watcher.Changed += OnFileChanged;
            _watcher.Created += OnFileChanged;
        }
    }
    
    public async Task<T?> GetContentTypeAsync<T>(string name) where T : class, IContentType
    {
        var cacheKey = $"{typeof(T).Name}:{name}";
        
        if (_cache.TryGetValue(cacheKey, out var cached))
        {
            return cached as T;
        }
        
        var filePath = GetContentFilePath<T>(name);
        
        if (!File.Exists(filePath))
        {
            return null;
        }
        
        try
        {
            var json = await File.ReadAllTextAsync(filePath);
            var content = JsonConvert.DeserializeObject<T>(json);
            
            if (_options.CacheContent)
            {
                _cache.TryAdd(cacheKey, content);
            }
            
            return content;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, $"Failed to load content type {name} of type {typeof(T).Name}");
            return null;
        }
    }
    
    public async Task<List<T>> GetAllContentTypesAsync<T>() where T : class, IContentType
    {
        var directory = GetContentDirectory<T>();
        
        if (!Directory.Exists(directory))
        {
            return new List<T>();
        }
        
        var files = Directory.GetFiles(directory, "*.json");
        var results = new List<T>();
        
        foreach (var file in files)
        {
            try
            {
                var json = await File.ReadAllTextAsync(file);
                var content = JsonConvert.DeserializeObject<T>(json);
                
                if (content != null)
                {
                    results.Add(content);
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, $"Failed to load content file {file}");
            }
        }
        
        return results;
    }
    
    public async Task SaveContentTypeAsync<T>(T contentType) where T : class, IContentType
    {
        var filePath = GetContentFilePath<T>(contentType.Name);
        var directory = Path.GetDirectoryName(filePath);
        
        if (!Directory.Exists(directory))
        {
            Directory.CreateDirectory(directory);
        }
        
        var json = JsonConvert.SerializeObject(contentType, Formatting.Indented);
        await File.WriteAllTextAsync(filePath, json);
        
        // Update cache
        var cacheKey = $"{typeof(T).Name}:{contentType.Name}";
        _cache.TryRemove(cacheKey, out _);
        
        // Raise event
        ContentChanged?.Invoke(this, new ContentChangedEventArgs
        {
            ContentType = typeof(T).Name,
            Name = contentType.Name,
            ChangeType = ContentChangeType.Updated
        });
    }
    
    // JSON Schema support
    public async Task<JSchema?> GetJsonSchemaAsync(string name)
    {
        var cacheKey = $"schema:{name}";
        
        if (_cache.TryGetValue(cacheKey, out var cached))
        {
            return cached as JSchema;
        }
        
        var filePath = Path.Combine(_options.ContentPath, "schemas", $"{name}.json");
        
        if (!File.Exists(filePath))
        {
            return null;
        }
        
        try
        {
            var json = await File.ReadAllTextAsync(filePath);
            var schema = JSchema.Parse(json);
            
            if (_options.CacheContent)
            {
                _cache.TryAdd(cacheKey, schema);
            }
            
            return schema;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, $"Failed to load schema {name}");
            return null;
        }
    }
    
    public async Task<bool> ValidateAgainstSchemaAsync(string schemaName, JObject data)
    {
        var schema = await GetJsonSchemaAsync(schemaName);
        
        if (schema == null)
        {
            _logger.LogWarning($"Schema {schemaName} not found");
            return true; // Allow if no schema
        }
        
        return data.IsValid(schema, out IList<string> errors);
    }
    
    // Satellite content
    public async Task<SatelliteJson?> GetSatelliteContentAsync(string name)
    {
        var cacheKey = $"satellite:{name}";
        
        if (_cache.TryGetValue(cacheKey, out var cached))
        {
            var satellite = cached as SatelliteJson;
            
            // Check if refresh needed
            if (satellite?.RefreshInterval.HasValue == true &&
                DateTime.UtcNow - satellite.LastLoaded > satellite.RefreshInterval.Value)
            {
                return await LoadSatelliteContent(name);
            }
            
            return satellite;
        }
        
        return await LoadSatelliteContent(name);
    }
    
    private async Task<SatelliteJson?> LoadSatelliteContent(string name)
    {
        var configPath = Path.Combine(_options.ContentPath, "satellites", $"{name}.config.json");
        
        if (!File.Exists(configPath))
        {
            return null;
        }
        
        try
        {
            var configJson = await File.ReadAllTextAsync(configPath);
            var config = JsonConvert.DeserializeObject<SatelliteConfig>(configJson);
            
            var contentPath = Path.IsPathRooted(config.FilePath) 
                ? config.FilePath 
                : Path.Combine(_options.ContentPath, config.FilePath);
                
            if (!File.Exists(contentPath))
            {
                _logger.LogWarning($"Satellite content file not found: {contentPath}");
                return null;
            }
            
            var contentJson = await File.ReadAllTextAsync(contentPath);
            var content = JObject.Parse(contentJson);
            
            var satellite = new SatelliteJson
            {
                Name = name,
                FilePath = config.FilePath,
                Content = content,
                LastLoaded = DateTime.UtcNow,
                FileSize = new FileInfo(contentPath).Length,
                ContentHash = ComputeHash(contentJson),
                WatchForChanges = config.WatchForChanges,
                RefreshInterval = config.RefreshInterval,
                CacheContent = config.CacheContent,
                SchemaFile = config.SchemaFile,
                ValidateOnLoad = config.ValidateOnLoad
            };
            
            // Validate if configured
            if (satellite.ValidateOnLoad && !string.IsNullOrEmpty(satellite.SchemaFile))
            {
                var isValid = await ValidateAgainstSchemaAsync(satellite.SchemaFile, content);
                if (!isValid)
                {
                    _logger.LogError($"Satellite content {name} failed schema validation");
                }
            }
            
            if (satellite.CacheContent)
            {
                _cache.TryAdd($"satellite:{name}", satellite);
            }
            
            return satellite;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, $"Failed to load satellite content {name}");
            return null;
        }
    }
    
    private void OnFileChanged(object sender, FileSystemEventArgs e)
    {
        // Clear cache for changed file
        var fileName = Path.GetFileNameWithoutExtension(e.Name);
        var keysToRemove = _cache.Keys
            .Where(k => k.Contains(fileName))
            .ToList();
            
        foreach (var key in keysToRemove)
        {
            _cache.TryRemove(key, out _);
        }
        
        // Raise event
        ContentChanged?.Invoke(this, new ContentChangedEventArgs
        {
            FilePath = e.FullPath,
            ChangeType = ContentChangeType.FileChanged
        });
    }
    
    public event EventHandler<ContentChangedEventArgs>? ContentChanged;
}
```

### Content Examples

#### Setting Up Content Structure
```csharp
public class ContentSetupService
{
    // Initialize content structure
    public async Task InitializeContentStructure()
    {
        // Create form templates
        await CreateFormTemplates();
        
        // Create work item templates
        await CreateWorkItemTemplates();
        
        // Create table templates
        await CreateTableTemplates();
        
        // Create notification templates
        await CreateNotificationTemplates();
        
        // Create report templates
        await CreateReportTemplates();
    }
    
    private async Task CreateFormTemplates()
    {
        // Customer feedback form
        var feedbackForm = new FormTemplate
        {
            Name = "CustomerFeedback",
            Title = "Customer Feedback Form",
            Tags = new List<string> { "feedback", "customer", "survey" },
            
            JsonSchema = JObject.FromObject(new
            {
                type = "object",
                properties = new
                {
                    customerName = new
                    {
                        type = "string",
                        title = "Customer Name",
                        minLength = 2,
                        maxLength = 100
                    },
                    email = new
                    {
                        type = "string",
                        title = "Email Address",
                        format = "email"
                    },
                    rating = new
                    {
                        type = "integer",
                        title = "Overall Rating",
                        minimum = 1,
                        maximum = 5
                    },
                    comments = new
                    {
                        type = "string",
                        title = "Comments",
                        maxLength = 1000
                    },
                    category = new
                    {
                        type = "string",
                        title = "Feedback Category",
                        @enum = new[] { "Product", "Service", "Support", "Other" }
                    }
                },
                required = new[] { "customerName", "email", "rating" }
            }),
            
            UISchema = JObject.FromObject(new
            {
                customerName = new { "ui:placeholder" = "Enter customer name" },
                email = new { "ui:placeholder" = "customer@example.com" },
                rating = new { "ui:widget" = "radio" },
                comments = new { "ui:widget" = "textarea", "ui:options" = new { rows = 4 } },
                category = new { "ui:widget" = "select" }
            }),
            
            // Form behavior
            AllowUserEdit = true,
            AllowComments = true,
            AllowFileAttachments = true,
            IsVisibleToUsers = true,
            
            // Actions
            Actions = new List<ActionButton>
            {
                new ActionButton
                {
                    Name = "submit",
                    Title = "Submit Feedback",
                    ButtonType = ActionButtonType.Submit,
                    Style = "primary"
                },
                new ActionButton
                {
                    Name = "draft",
                    Title = "Save as Draft",
                    ButtonType = ActionButtonType.Custom,
                    Style = "secondary"
                }
            }
        };
        
        await _content.SaveContentTypeAsync(feedbackForm);
        
        // Contact form
        var contactForm = new FormTemplate
        {
            Name = "ContactForm",
            Title = "Contact Us",
            Tags = new List<string> { "contact", "inquiry" },
            
            JsonSchema = JObject.FromObject(new
            {
                type = "object",
                properties = new
                {
                    firstName = new { type = "string", title = "First Name" },
                    lastName = new { type = "string", title = "Last Name" },
                    email = new { type = "string", title = "Email", format = "email" },
                    phone = new { type = "string", title = "Phone Number" },
                    subject = new { type = "string", title = "Subject" },
                    message = new { type = "string", title = "Message" },
                    urgency = new
                    {
                        type = "string",
                        title = "Urgency",
                        @enum = new[] { "Low", "Medium", "High", "Urgent" },
                        @default = "Medium"
                    }
                },
                required = new[] { "firstName", "lastName", "email", "subject", "message" }
            })
        };
        
        await _content.SaveContentTypeAsync(contactForm);
    }
    
    private async Task CreateWorkItemTemplates()
    {
        // Support ticket template
        var supportTicket = new WorkItemTemplate
        {
            Name = "SupportTicket",
            Title = "Support Ticket",
            Tags = new List<string> { "support", "ticket", "helpdesk" },
            
            // Status configuration
            StatusTemplates = new List<StatusTemplate>
            {
                new StatusTemplate { Value = 0, Name = "New", Color = "#blue", IsResolved = false },
                new StatusTemplate { Value = 1, Name = "In Progress", Color = "#yellow", IsResolved = false },
                new StatusTemplate { Value = 2, Name = "Waiting for Customer", Color = "#orange", IsResolved = false },
                new StatusTemplate { Value = 3, Name = "Resolved", Color = "#green", IsResolved = true },
                new StatusTemplate { Value = 4, Name = "Closed", Color = "#gray", IsResolved = true }
            },
            
            // Priority configuration
            PriorityTemplates = new List<PriorityTemplate>
            {
                new PriorityTemplate { Value = 1, Name = "Low", Color = "#gray" },
                new PriorityTemplate { Value = 2, Name = "Medium", Color = "#blue" },
                new PriorityTemplate { Value = 3, Name = "High", Color = "#orange" },
                new PriorityTemplate { Value = 4, Name = "Critical", Color = "#red" }
            },
            
            // Sections
            SectionTemplates = new List<SectionTemplate>
            {
                new SectionTemplate
                {
                    Name = "CustomerInfo",
                    Title = "Customer Information",
                    EntityTypes = new[] { "Form" },
                    AllowedTemplates = new[] { "CustomerContactForm" },
                    IsRequired = true
                },
                new SectionTemplate
                {
                    Name = "IssueDetails",
                    Title = "Issue Details",
                    EntityTypes = new[] { "Form" },
                    AllowedTemplates = new[] { "IssueDescriptionForm" },
                    IsRequired = true
                },
                new SectionTemplate
                {
                    Name = "Resolution",
                    Title = "Resolution",
                    EntityTypes = new[] { "Form" },
                    AllowedTemplates = new[] { "ResolutionForm" },
                    IsRequired = false
                }
            },
            
            // Permissions
            AllowUserEdit = true,
            AllowUserAddMembers = false,
            AllowComments = true,
            AllowFileAttachments = true,
            IsVisibleToUsers = true
        };
        
        await _content.SaveContentTypeAsync(supportTicket);
    }
}
```

#### Creating a Content Domain System
```csharp
public class ContentDomainService
{
    // Create application settings domain
    public async Task<ContentDomain> CreateApplicationSettingsDomain()
    {
        var domain = new ContentDomain
        {
            Name = "ApplicationSettings",
            Title = "Application Settings",
            Description = "Global application configuration and settings",
            Tags = new List<string> { "settings", "configuration", "admin" },
            
            Elements = new List<ContentElement>
            {
                new ContentElement
                {
                    Key = "app.name",
                    Title = "Application Name",
                    Type = ContentElementType.String,
                    Value = JToken.FromObject("BForm Platform"),
                    IsRequired = true
                },
                new ContentElement
                {
                    Key = "app.version",
                    Title = "Application Version",
                    Type = ContentElementType.String,
                    Value = JToken.FromObject("1.0.0")
                },
                new ContentElement
                {
                    Key = "features.enableComments",
                    Title = "Enable Comments",
                    Type = ContentElementType.Boolean,
                    Value = JToken.FromObject(true)
                },
                new ContentElement
                {
                    Key = "features.enableFileAttachments",
                    Title = "Enable File Attachments",
                    Type = ContentElementType.Boolean,
                    Value = JToken.FromObject(true)
                },
                new ContentElement
                {
                    Key = "limits.maxFileSize",
                    Title = "Maximum File Size (MB)",
                    Type = ContentElementType.Number,
                    Value = JToken.FromObject(50)
                },
                new ContentElement
                {
                    Key = "security.requireEmailVerification",
                    Title = "Require Email Verification",
                    Type = ContentElementType.Boolean,
                    Value = JToken.FromObject(true)
                },
                new ContentElement
                {
                    Key = "ui.theme",
                    Title = "UI Theme",
                    Type = ContentElementType.Object,
                    Value = JObject.FromObject(new
                    {
                        primaryColor = "#007bff",
                        secondaryColor = "#6c757d",
                        successColor = "#28a745",
                        warningColor = "#ffc107",
                        errorColor = "#dc3545"
                    })
                }
            },
            
            SchemaName = "ApplicationSettingsSchema",
            ValidateContent = true,
            AllowedRoles = new List<string> { "Administrator" },
            IsPublic = false,
            Version = "1.0",
            LastModified = DateTime.UtcNow
        };
        
        await _content.SaveContentDomainAsync(domain);
        return domain;
    }
    
    // Create localization content domain
    public async Task CreateLocalizationDomain()
    {
        var uiStringsDomain = new ContentDomain
        {
            Name = "UIStrings",
            Title = "User Interface Strings",
            Description = "Localized UI text and messages",
            Tags = new List<string> { "localization", "ui", "strings" },
            
            Elements = new List<ContentElement>
            {
                new ContentElement
                {
                    Key = "common.save",
                    Title = "Save Button Text",
                    Type = ContentElementType.String,
                    Value = JToken.FromObject("Save"),
                    Localizations = new Dictionary<string, JToken>
                    {
                        ["es"] = JToken.FromObject("Guardar"),
                        ["fr"] = JToken.FromObject("Enregistrer"),
                        ["de"] = JToken.FromObject("Speichern")
                    }
                },
                new ContentElement
                {
                    Key = "common.cancel",
                    Title = "Cancel Button Text",
                    Type = ContentElementType.String,
                    Value = JToken.FromObject("Cancel"),
                    Localizations = new Dictionary<string, JToken>
                    {
                        ["es"] = JToken.FromObject("Cancelar"),
                        ["fr"] = JToken.FromObject("Annuler"),
                        ["de"] = JToken.FromObject("Abbrechen")
                    }
                },
                new ContentElement
                {
                    Key = "validation.required",
                    Title = "Required Field Message",
                    Type = ContentElementType.String,
                    Value = JToken.FromObject("This field is required"),
                    Localizations = new Dictionary<string, JToken>
                    {
                        ["es"] = JToken.FromObject("Este campo es obligatorio"),
                        ["fr"] = JToken.FromObject("Ce champ est obligatoire"),
                        ["de"] = JToken.FromObject("Dieses Feld ist erforderlich")
                    }
                }
            }
        };
        
        await _content.SaveContentDomainAsync(uiStringsDomain);
    }
}
```

### Best Practices

1. **Structure content logically** - Organize templates and content into clear hierarchies
2. **Use JSON schemas** - Validate content structure and data integrity
3. **Implement version control** - Track changes to content over time
4. **Cache frequently accessed content** - Improve performance with smart caching
5. **Support localization** - Enable multi-language applications
6. **Separate concerns** - Keep configuration separate from business logic
7. **Validate content changes** - Ensure data quality and consistency
8. **Document content structure** - Provide clear guidance for content creators
9. **Use file watching** - Enable hot-reload for development
10. **Implement access controls** - Secure sensitive configuration data

---

## Rules Engine

The Rules Engine provides sophisticated event-driven automation through configurable business rules. It supports complex condition evaluation, action chaining, and plugin-based extensibility for custom behaviors.

### Core Components

#### Rule
Defines a complete business rule with conditions and actions:

```csharp
public class Rule : IContentType
{
    public string Name { get; set; }                // Unique identifier
    public string Title { get; set; }               // Display title
    public List<string> Tags { get; set; } = new(); // Categorization
    
    // Trigger configuration
    public List<string> TopicBindings { get; set; } = new(); // Event topics
    public List<RuleCondition> Conditions { get; set; } = new(); // When to execute
    public RuleLogicOperator ConditionLogic { get; set; } = RuleLogicOperator.And;
    
    // Actions
    public List<RuleAction> Actions { get; set; } = new(); // What to do
    public bool StopOnFirstFailure { get; set; } = false; // Error handling
    
    // Execution control
    public bool IsEnabled { get; set; } = true;    // Rule active
    public int Priority { get; set; } = 100;       // Execution order
    public TimeSpan? Timeout { get; set; }         // Max execution time
    
    // Rate limiting
    public TimeSpan? CooldownPeriod { get; set; }  // Minimum time between executions
    public int? MaxExecutionsPerHour { get; set; } // Rate limit
    
    // Scheduling
    public DateTime? ActiveFrom { get; set; }      // Activation date
    public DateTime? ActiveUntil { get; set; }     // Deactivation date
    public List<string> ActiveDays { get; set; } = new(); // Days of week
    public TimeSpan? ActiveStartTime { get; set; } // Daily start time
    public TimeSpan? ActiveEndTime { get; set; }   // Daily end time
    
    // Context
    public List<string> RequiredRoles { get; set; } = new(); // User roles
    public List<string> RequiredTags { get; set; } = new(); // Entity tags
    public JObject? Metadata { get; set; }         // Additional data
}

public enum RuleLogicOperator
{
    And = 0,    // All conditions must be true
    Or = 1      // Any condition must be true
}
```

#### RuleCondition
Defines when a rule should execute:

```csharp
public class RuleCondition
{
    public string? Query { get; set; }              // JSONPath query
    public RuleConditionCheck Check { get; set; }   // Comparison type
    public JToken? Value { get; set; }              // Expected value
    public bool Negate { get; set; }               // Invert result
    
    // Advanced comparisons
    public List<JToken>? Values { get; set; }      // Multiple values
    public double? NumericTolerance { get; set; }   // Floating point tolerance
    public bool CaseSensitive { get; set; } = true; // String comparison
    
    // Contextual conditions
    public string? EntityType { get; set; }        // Entity type filter
    public string? UserRole { get; set; }          // User role requirement
    public List<string>? RequiredTags { get; set; } // Tag requirements
}

public enum RuleConditionCheck
{
    Exists = 0,         // Value exists
    NotExists = 1,      // Value doesn't exist
    Equals = 2,         // Value equals
    NotEquals = 3,      // Value not equals
    GreaterThan = 4,    // Numeric comparison
    LessThan = 5,       // Numeric comparison
    GreaterOrEqual = 6, // Numeric comparison
    LessOrEqual = 7,    // Numeric comparison
    Contains = 8,       // String/array contains
    NotContains = 9,    // String/array doesn't contain
    StartsWith = 10,    // String starts with
    EndsWith = 11,      // String ends with
    Matches = 12,       // Regex match
    In = 13,           // Value in list
    NotIn = 14,        // Value not in list
    Any = 15,          // Any array element matches
    All = 16,          // All array elements match
    Count = 17,        // Array count
    Empty = 18,        // Array/string is empty
    NotEmpty = 19      // Array/string not empty
}
```

#### RuleAction
Base class for rule actions:

```csharp
public class RuleAction
{
    public RuleExpressionInvocation Invocation { get; set; } // Action to execute
    public int Priority { get; set; } = 100;     // Execution order
    public bool ContinueOnError { get; set; } = true; // Error handling
    public TimeSpan? Timeout { get; set; }      // Max execution time
    public List<RuleCondition>? Conditions { get; set; } // Action-specific conditions
}

public class RuleExpressionInvocation
{
    public string Name { get; set; }            // Action name
    public JObject Args { get; set; }           // Action arguments
    public string? ResultProperty { get; set; } // Where to store result
    public bool Required { get; set; } = true;  // Fail if action fails
}
```

### Rule Services

#### RuleEngine
Core rule processing engine:

```csharp
public class RuleEngine : IAppEventConsumer
{
    private readonly IApplicationPlatformContent _content;
    private readonly TopicRegistrations _topicRegistrations;
    private readonly RuleEvaluator _evaluator;
    private readonly ILogger<RuleEngine> _logger;
    
    public void ConsumeEvents(AppEvent appEvent)
    {
        _ = Task.Run(async () => await ProcessEventAsync(appEvent));
    }
    
    private async Task ProcessEventAsync(AppEvent appEvent)
    {
        try
        {
            // Get rules for this topic
            var rules = await GetRulesForTopic(appEvent.Topic);
            
            if (!rules.Any())
            {
                return;
            }
            
            // Process rules by priority
            var sortedRules = rules
                .Where(r => r.IsEnabled && IsRuleActive(r))
                .OrderBy(r => r.Priority)
                .ToList();
                
            foreach (var rule in sortedRules)
            {
                try
                {
                    // Check rate limiting
                    if (!await CheckRateLimit(rule, appEvent))
                    {
                        continue;
                    }
                    
                    // Evaluate rule
                    await _evaluator.EvaluateRuleAsync(rule, appEvent);
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, $"Failed to evaluate rule {rule.Name} for event {appEvent.Id}");
                }
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, $"Failed to process event {appEvent.Id} in rule engine");
        }
    }
    
    private async Task<List<Rule>> GetRulesForTopic(string? topic)
    {
        if (string.IsNullOrEmpty(topic))
        {
            return new List<Rule>();
        }
        
        var allRules = await _content.GetAllContentTypesAsync<Rule>();
        
        return allRules
            .Where(r => r.TopicBindings.Any(binding => IsTopicMatch(topic, binding)))
            .ToList();
    }
    
    private bool IsTopicMatch(string eventTopic, string ruleBinding)
    {
        // Support wildcards in rule bindings
        if (ruleBinding.Contains("*"))
        {
            var pattern = ruleBinding.Replace("*", ".*");
            return Regex.IsMatch(eventTopic, pattern);
        }
        
        return eventTopic.Equals(ruleBinding, StringComparison.OrdinalIgnoreCase);
    }
    
    private bool IsRuleActive(Rule rule)
    {
        var now = DateTime.UtcNow;
        
        // Check date range
        if (rule.ActiveFrom.HasValue && now < rule.ActiveFrom.Value)
        {
            return false;
        }
        
        if (rule.ActiveUntil.HasValue && now > rule.ActiveUntil.Value)
        {
            return false;
        }
        
        // Check day of week
        if (rule.ActiveDays.Any())
        {
            var currentDay = now.DayOfWeek.ToString();
            if (!rule.ActiveDays.Contains(currentDay))
            {
                return false;
            }
        }
        
        // Check time of day
        if (rule.ActiveStartTime.HasValue || rule.ActiveEndTime.HasValue)
        {
            var currentTime = now.TimeOfDay;
            
            if (rule.ActiveStartTime.HasValue && currentTime < rule.ActiveStartTime.Value)
            {
                return false;
            }
            
            if (rule.ActiveEndTime.HasValue && currentTime > rule.ActiveEndTime.Value)
            {
                return false;
            }
        }
        
        return true;
    }
}
```

#### RuleEvaluator
Evaluates individual rules:

```csharp
public class RuleEvaluator
{
    private readonly Dictionary<string, IRuleActionEvaluator> _actionEvaluators;
    private readonly Dictionary<string, IEventAppender> _eventAppenders;
    private readonly ILogger<RuleEvaluator> _logger;
    
    public async Task<RuleEvaluationResult> EvaluateRuleAsync(Rule rule, AppEvent appEvent)
    {
        var stopwatch = Stopwatch.StartNew();
        var result = new RuleEvaluationResult
        {
            RuleName = rule.Name,
            EventId = appEvent.Id,
            StartTime = DateTime.UtcNow
        };
        
        try
        {
            // Prepare event data
            var eventData = JObject.Parse(appEvent.EntityPayload.ToJson());
            
            // Apply event appenders
            await ApplyEventAppenders(rule, eventData, appEvent);
            
            // Evaluate conditions
            var conditionsResult = await EvaluateConditions(rule, eventData);
            result.ConditionsMet = conditionsResult;
            
            if (!conditionsResult)
            {
                result.Status = RuleEvaluationStatus.ConditionsNotMet;
                return result;
            }
            
            // Execute actions
            await ExecuteActions(rule, eventData, result);
            
            result.Status = RuleEvaluationStatus.Success;
        }
        catch (Exception ex)
        {
            result.Status = RuleEvaluationStatus.Failed;
            result.ErrorMessage = ex.Message;
            _logger.LogError(ex, $"Rule evaluation failed for rule {rule.Name}");
        }
        finally
        {
            result.Duration = stopwatch.Elapsed;
        }
        
        return result;
    }
    
    private async Task<bool> EvaluateConditions(Rule rule, JObject eventData)
    {
        if (!rule.Conditions.Any())
        {
            return true; // No conditions means always execute
        }
        
        var results = new List<bool>();
        
        foreach (var condition in rule.Conditions)
        {
            var conditionResult = await EvaluateCondition(condition, eventData);
            results.Add(conditionResult);
        }
        
        // Apply logic operator
        return rule.ConditionLogic == RuleLogicOperator.And
            ? results.All(r => r)
            : results.Any(r => r);
    }
    
    private async Task<bool> EvaluateCondition(RuleCondition condition, JObject eventData)
    {
        try
        {
            // Get value from event data
            JToken? actualValue = null;
            
            if (!string.IsNullOrEmpty(condition.Query))
            {
                actualValue = eventData.SelectToken(condition.Query);
            }
            
            // Perform comparison
            var result = condition.Check switch
            {
                RuleConditionCheck.Exists => actualValue != null,
                RuleConditionCheck.NotExists => actualValue == null,
                RuleConditionCheck.Equals => CompareValues(actualValue, condition.Value, condition),
                RuleConditionCheck.NotEquals => !CompareValues(actualValue, condition.Value, condition),
                RuleConditionCheck.GreaterThan => CompareNumeric(actualValue, condition.Value, (a, b) => a > b),
                RuleConditionCheck.LessThan => CompareNumeric(actualValue, condition.Value, (a, b) => a < b),
                RuleConditionCheck.GreaterOrEqual => CompareNumeric(actualValue, condition.Value, (a, b) => a >= b),
                RuleConditionCheck.LessOrEqual => CompareNumeric(actualValue, condition.Value, (a, b) => a <= b),
                RuleConditionCheck.Contains => ContainsValue(actualValue, condition.Value, condition),
                RuleConditionCheck.StartsWith => StartsWithValue(actualValue, condition.Value, condition),
                RuleConditionCheck.EndsWith => EndsWithValue(actualValue, condition.Value, condition),
                RuleConditionCheck.Matches => MatchesRegex(actualValue, condition.Value),
                RuleConditionCheck.In => IsInValues(actualValue, condition.Values),
                RuleConditionCheck.Empty => IsEmpty(actualValue),
                RuleConditionCheck.NotEmpty => !IsEmpty(actualValue),
                _ => false
            };
            
            return condition.Negate ? !result : result;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, $"Failed to evaluate condition: {condition.Query}");
            return false;
        }
    }
    
    private async Task ExecuteActions(Rule rule, JObject eventData, RuleEvaluationResult result)
    {
        var sortedActions = rule.Actions.OrderBy(a => a.Priority).ToList();
        
        foreach (var action in sortedActions)
        {
            var actionResult = new ActionEvaluationResult
            {
                ActionName = action.Invocation.Name,
                StartTime = DateTime.UtcNow
            };
            
            try
            {
                // Check action-specific conditions
                if (action.Conditions != null && action.Conditions.Any())
                {
                    var actionConditionsRule = new Rule
                    {
                        Conditions = action.Conditions,
                        ConditionLogic = RuleLogicOperator.And
                    };
                    
                    var conditionsMet = await EvaluateConditions(actionConditionsRule, eventData);
                    if (!conditionsMet)
                    {
                        actionResult.Status = ActionEvaluationStatus.ConditionsNotMet;
                        result.ActionResults.Add(actionResult);
                        continue;
                    }
                }
                
                // Execute action
                var evaluator = _actionEvaluators[action.Invocation.Name];
                var updatedEventData = await evaluator.EvaluateAsync(action.Invocation.Args, eventData);
                
                // Update event data with results
                if (!string.IsNullOrEmpty(action.Invocation.ResultProperty))
                {
                    eventData[action.Invocation.ResultProperty] = JToken.FromObject(updatedEventData);
                }
                else
                {
                    eventData.Merge(updatedEventData);
                }
                
                actionResult.Status = ActionEvaluationStatus.Success;
            }
            catch (Exception ex)
            {
                actionResult.Status = ActionEvaluationStatus.Failed;
                actionResult.ErrorMessage = ex.Message;
                
                if (!action.ContinueOnError)
                {
                    result.ActionResults.Add(actionResult);
                    throw;
                }
            }
            finally
            {
                actionResult.Duration = DateTime.UtcNow - actionResult.StartTime;
                result.ActionResults.Add(actionResult);
            }
        }
    }
}
```

### Event Appenders

Event appenders enhance event data before rule evaluation:

#### IEventAppender
Base interface for event appenders:

```csharp
public interface IEventAppender
{
    string Name { get; }
    Task AppendAsync(JObject eventData, JObject parameters);
}
```

#### CurrentDateTimeAppender
Adds current timestamp:

```csharp
public class CurrentDateTimeAppender : IEventAppender
{
    public string Name => "CurrentDateTime";
    
    public Task AppendAsync(JObject eventData, JObject parameters)
    {
        var property = parameters["property"]?.ToString() ?? "currentDateTime";
        var format = parameters["format"]?.ToString();
        
        var now = DateTime.UtcNow;
        
        if (!string.IsNullOrEmpty(format))
        {
            eventData[property] = now.ToString(format);
        }
        else
        {
            eventData[property] = now;
        }
        
        return Task.CompletedTask;
    }
}
```

#### LoadEntityDataFromReferenceAppender
Loads related entity data:

```csharp
public class LoadEntityDataFromReferenceAppender : IEventAppender
{
    private readonly EntityReferenceLoader _entityLoader;
    
    public string Name => "LoadEntityData";
    
    public async Task AppendAsync(JObject eventData, JObject parameters)
    {
        var referenceQuery = parameters["referenceQuery"]?.ToString();
        var targetProperty = parameters["targetProperty"]?.ToString() ?? "entityData";
        var fields = parameters["fields"]?.ToObject<string[]>();
        
        if (string.IsNullOrEmpty(referenceQuery))
        {
            return;
        }
        
        var reference = eventData.SelectToken(referenceQuery)?.ToString();
        if (string.IsNullOrEmpty(reference))
        {
            return;
        }
        
        try
        {
            var entityData = await _entityLoader.LoadJson(reference);
            
            if (entityData != null)
            {
                if (fields != null && fields.Any())
                {
                    // Only include specified fields
                    var filteredData = new JObject();
                    foreach (var field in fields)
                    {
                        var value = entityData.SelectToken(field);
                        if (value != null)
                        {
                            filteredData[field] = value;
                        }
                    }
                    eventData[targetProperty] = filteredData;
                }
                else
                {
                    eventData[targetProperty] = entityData;
                }
            }
        }
        catch (Exception ex)
        {
            eventData[$"{targetProperty}_error"] = ex.Message;
        }
    }
}
```

### Rule Examples

#### Creating User Notification Rules
```csharp
public class UserNotificationRules
{
    // Welcome new users
    public static Rule CreateWelcomeUserRule()
    {
        return new Rule
        {
            Name = "WelcomeNewUser",
            Title = "Welcome New User",
            Tags = new List<string> { "user", "onboarding", "notification" },
            
            TopicBindings = new List<string> { "User.Created" },
            
            Conditions = new List<RuleCondition>
            {
                new RuleCondition
                {
                    Query = "$.EmailVerified",
                    Check = RuleConditionCheck.Equals,
                    Value = JToken.FromObject(true)
                }
            },
            
            Actions = new List<RuleAction>
            {
                // Send welcome email
                new RuleAction
                {
                    Priority = 1,
                    Invocation = new RuleExpressionInvocation
                    {
                        Name = "RuleActionRequestNotification",
                        Args = JObject.FromObject(new
                        {
                            NotificationTemplate = "WelcomeEmail",
                            UserIdQuery = "$.Id",
                            Parameters = new
                            {
                                UserName = "$.DisplayName",
                                LoginUrl = "#{BaseUrl}/login"
                            }
                        })
                    }
                },
                // Create personal workspace
                new RuleAction
                {
                    Priority = 2,
                    Invocation = new RuleExpressionInvocation
                    {
                        Name = "RuleActionCreateWorkSet",
                        Args = JObject.FromObject(new
                        {
                            TemplateName = "PersonalWorkspace",
                            TitleQuery = "$.DisplayName + '''s Workspace'",
                            Description = "Personal workspace for organizing your work",
                            Settings = new
                            {
                                isPersonal = true,
                                theme = "default"
                            }
                        }),
                        ResultProperty = "personalWorkspaceId"
                    }
                },
                // Log onboarding event
                new RuleAction
                {
                    Priority = 3,
                    Invocation = new RuleExpressionInvocation
                    {
                        Name = "RuleActionLogEventData",
                        Args = JObject.FromObject(new
                        {
                            EventType = "UserOnboarded",
                            Message = "User successfully onboarded with personal workspace",
                            Data = new
                            {
                                UserId = "$.Id",
                                WorkspaceId = "$.personalWorkspaceId"
                            }
                        })
                    }
                }
            },
            
            IsEnabled = true,
            Priority = 100
        };
    }
    
    // Notify on high priority work items
    public static Rule CreateHighPriorityWorkItemRule()
    {
        return new Rule
        {
            Name = "HighPriorityWorkItemNotification",
            Title = "High Priority Work Item Notification",
            Tags = new List<string> { "workitem", "priority", "notification" },
            
            TopicBindings = new List<string> 
            { 
                "WorkItem.Created", 
                "WorkItem.Updated" 
            },
            
            Conditions = new List<RuleCondition>
            {
                new RuleCondition
                {
                    Query = "$.Priority",
                    Check = RuleConditionCheck.GreaterOrEqual,
                    Value = JToken.FromObject(3) // High or Critical
                },
                new RuleCondition
                {
                    Query = "$.Status",
                    Check = RuleConditionCheck.NotEquals,
                    Value = JToken.FromObject(4) // Not closed
                }
            },
            
            Actions = new List<RuleAction>
            {
                new RuleAction
                {
                    Invocation = new RuleExpressionInvocation
                    {
                        Name = "RuleActionRequestNotification",
                        Args = JObject.FromObject(new
                        {
                            GroupByTags = new[] { "manager", "supervisor" },
                            Subject = "High Priority Work Item Requires Attention",
                            EmailText = "A high priority work item has been created or updated and requires immediate attention.",
                            ToastText = "High priority work item needs attention",
                            Channels = new[] { "Email", "Toast", "SMS" },
                            Priority = "High",
                            ActionUrl = "/workitem/$.Id"
                        })
                    }
                }
            },
            
            // Rate limiting to prevent spam
            CooldownPeriod = TimeSpan.FromMinutes(15),
            MaxExecutionsPerHour = 4,
            
            IsEnabled = true,
            Priority = 50 // Higher priority than normal rules
        };
    }
}
```

#### Creating Data Processing Rules
```csharp
public class DataProcessingRules
{
    // Process form submissions
    public static Rule CreateFormSubmissionProcessingRule()
    {
        return new Rule
        {
            Name = "ProcessFormSubmission",
            Title = "Process Form Submission",
            Tags = new List<string> { "form", "data-processing", "automation" },
            
            TopicBindings = new List<string> { "Form.Submitted" },
            
            Conditions = new List<RuleCondition>
            {
                new RuleCondition
                {
                    Query = "$.Template",
                    Check = RuleConditionCheck.In,
                    Values = new List<JToken>
                    {
                        JToken.FromObject("CustomerFeedback"),
                        JToken.FromObject("ContactForm"),
                        JToken.FromObject("SupportRequest")
                    }
                }
            },
            
            Actions = new List<RuleAction>
            {
                // Insert into analytics table
                new RuleAction
                {
                    Priority = 1,
                    Invocation = new RuleExpressionInvocation
                    {
                        Name = "RuleActionInsertTableData",
                        Args = JObject.FromObject(new
                        {
                            TableTemplate = "FormSubmissions",
                            Map = new[]
                            {
                                new { ToField = "formId", FromQuery = "$.Id" },
                                new { ToField = "formTemplate", FromQuery = "$.Template" },
                                new { ToField = "submittedAt", FromQuery = "$.UpdatedDate" },
                                new { ToField = "submittedBy", FromQuery = "$.LastModifier" },
                                new { ToField = "workSetId", FromQuery = "$.HostWorkSet" },
                                new { ToField = "dataSize", FromQuery = "$.Content | length" }
                            },
                            Tags = new[] { "analytics", "submission" }
                        })
                    }
                },
                // Create work item for follow-up
                new RuleAction
                {
                    Priority = 2,
                    Conditions = new List<RuleCondition>
                    {
                        new RuleCondition
                        {
                            Query = "$.Template",
                            Check = RuleConditionCheck.Equals,
                            Value = JToken.FromObject("SupportRequest")
                        }
                    },
                    Invocation = new RuleExpressionInvocation
                    {
                        Name = "RuleActionCreateWorkItem",
                        Args = JObject.FromObject(new
                        {
                            TemplateName = "SupportTicket",
                            WorkSetQuery = "$.HostWorkSet",
                            TitleQuery = "'Support Request: ' + $.Content.subject",
                            Description = "Support request submitted via form",
                            UserAssigneeQuery = "#{SupportTeamLeadId}",
                            Priority = 2,
                            Sections = new
                            {
                                CustomerInfo = new
                                {
                                    EntityType = "Form",
                                    EntityId = "$.Id"
                                }
                            }
                        }),
                        ResultProperty = "supportTicketId"
                    }
                },
                // Send confirmation
                new RuleAction
                {
                    Priority = 3,
                    Invocation = new RuleExpressionInvocation
                    {
                        Name = "RuleActionRequestNotification",
                        Args = JObject.FromObject(new
                        {
                            UserIdQuery = "$.LastModifier",
                            NotificationTemplate = "FormSubmissionConfirmation",
                            Parameters = new
                            {
                                FormType = "$.Template",
                                SubmissionId = "$.Id",
                                TicketId = "$.supportTicketId"
                            }
                        })
                    }
                }
            },
            
            IsEnabled = true,
            Priority = 100
        };
    }
    
    // Automated data quality checks
    public static Rule CreateDataQualityRule()
    {
        return new Rule
        {
            Name = "DataQualityCheck",
            Title = "Automated Data Quality Check",
            Tags = new List<string> { "data-quality", "validation", "monitoring" },
            
            TopicBindings = new List<string> 
            { 
                "Table.*.RowInserted",
                "Table.*.RowUpdated" 
            },
            
            Actions = new List<RuleAction>
            {
                // Check for duplicate records
                new RuleAction
                {
                    Priority = 1,
                    Invocation = new RuleExpressionInvocation
                    {
                        Name = "RuleActionSelectTableRows",
                        Args = JObject.FromObject(new
                        {
                            TableTemplateQuery = "$.OriginTemplate.replace('Table.', '').replace('.RowInserted', '')",
                            Filter = new
                            {
                                email = "$.EntityPayload.email",
                                Id = new { $ne = "$.OriginId" }
                            },
                            MaxRows = 1
                        }),
                        ResultProperty = "duplicateCheck"
                    }
                },
                // Flag potential duplicates
                new RuleAction
                {
                    Priority = 2,
                    Conditions = new List<RuleCondition>
                    {
                        new RuleCondition
                        {
                            Query = "$.duplicateCheck.length",
                            Check = RuleConditionCheck.GreaterThan,
                            Value = JToken.FromObject(0)
                        }
                    },
                    Invocation = new RuleExpressionInvocation
                    {
                        Name = "RuleActionCustomEvent",
                        Args = JObject.FromObject(new
                        {
                            Topic = "DataQuality.DuplicateDetected",
                            Data = new
                            {
                                TableTemplate = "$.OriginTemplate",
                                RecordId = "$.OriginId",
                                DuplicateIds = "$.duplicateCheck[*].Id",
                                MatchedField = "email"
                            }
                        })
                    }
                }
            },
            
            IsEnabled = true,
            Priority = 200
        };
    }
}
```

### Best Practices

1. **Design atomic rules** - Keep rules focused on single responsibilities
2. **Use meaningful conditions** - Make rule logic clear and maintainable
3. **Implement proper error handling** - Use ContinueOnError appropriately
4. **Apply rate limiting** - Prevent rule execution spam
5. **Order actions by priority** - Control execution sequence
6. **Use wildcards judiciously** - Balance flexibility with performance
7. **Test rule logic thoroughly** - Validate conditions and actions
8. **Monitor rule performance** - Track execution times and failures
9. **Document rule purposes** - Explain business logic clearly
10. **Version rule definitions** - Track changes over time

---

## AppEvents System

The AppEvents System provides the foundational event-driven architecture that enables loose coupling, audit trails, and real-time processing across the platform. It handles event generation, distribution, and consumption with reliability and scalability.

### Core Components

#### AppEvent
The central event model:

```csharp
public class AppEvent : IDataModel
{
    public Guid Id { get; set; }
    public int Version { get; set; }
    
    // Event classification
    public string? Topic { get; set; }              // Event type/category
    public string? OriginEntityType { get; set; }   // Source entity type
    public string? OriginTemplate { get; set; }     // Source template
    public Guid? OriginId { get; set; }             // Source entity ID
    
    // Event correlation
    public Guid EventLine { get; set; }            // Groups related events
    public int EventGeneration { get; set; }        // Distance from root event
    public bool IsNatural { get; set; }            // User vs system generated
    
    // Processing state
    public AppEventState State { get; set; }        // Current state
    public DateTime CreatedDate { get; set; }       // When created
    public DateTime DeferredUntil { get; set; }     // When to process
    public DateTime TakenExpiration { get; set; }   // Processing timeout
    public string? ProcessorId { get; set; }        // Who's processing
    
    // Event data
    public BsonDocument EntityPayload { get; set; } // Event payload
    public List<string> Tags { get; set; } = new(); // Event tags
    public List<string> EntityTags { get; set; } = new(); // Source entity tags
    
    // Metadata
    public JObject? Metadata { get; set; }          // Additional data
    public string? CorrelationId { get; set; }      // External correlation
    public string? CausationId { get; set; }        // Causing event
}

public enum AppEventState
{
    Pending = 0,        // Waiting to be processed
    Taken = 1,          // Being processed
    Completed = 2,      // Successfully processed
    Failed = 3,         // Processing failed
    Deferred = 4,       // Postponed processing
    Cancelled = 5       // Cancelled
}
```

#### AppEventOrigin
Tracks event sources:

```csharp
public class AppEventOrigin
{
    public string EntityType { get; set; }         // Source entity type
    public string? Template { get; set; }          // Source template
    public Guid Id { get; set; }                   // Source entity ID
    public List<string> Tags { get; set; } = new(); // Source tags
    
    public static AppEventOrigin FromEntity<T>(T entity) where T : IAppEntity
    {
        return new AppEventOrigin
        {
            EntityType = entity.EntityType,
            Template = entity.Template,
            Id = entity.Id,
            Tags = entity.Tags
        };
    }
}
```

### Event Services

#### AppEventSink
Receives and stores events:

```csharp
public class AppEventSink
{
    private readonly IRepository<AppEvent> _eventRepo;
    private readonly AppEventSinkOptions _options;
    
    public async Task SinkAsync(
        string topic,
        AppEventOrigin origin,
        BsonDocument payload,
        bool isNatural = true,
        Guid? eventLine = null,
        int eventGeneration = 0,
        CancellationToken cancellationToken = default)
    {
        var appEvent = new AppEvent
        {
            Topic = topic,
            OriginEntityType = origin.EntityType,
            OriginTemplate = origin.Template,
            OriginId = origin.Id,
            EntityPayload = payload,
            EntityTags = origin.Tags,
            IsNatural = isNatural,
            EventLine = eventLine ?? Guid.NewGuid(),
            EventGeneration = eventGeneration,
            State = AppEventState.Pending,
            CreatedDate = DateTime.UtcNow,
            DeferredUntil = DateTime.UtcNow
        };
        
        // Apply event enrichment
        await EnrichEvent(appEvent);
        
        using (var tc = await _eventRepo.OpenTransactionAsync(cancellationToken))
        {
            await _eventRepo.CreateAsync(tc, appEvent, cancellationToken);
            await tc.CommitAsync(cancellationToken);
        }
    }
    
    public async Task SinkAsync(
        ITransactionContext transactionContext,
        string topic,
        AppEventOrigin origin,
        BsonDocument payload,
        bool isNatural = true,
        Guid? eventLine = null,
        int eventGeneration = 0,
        CancellationToken cancellationToken = default)
    {
        var appEvent = new AppEvent
        {
            Topic = topic,
            OriginEntityType = origin.EntityType,
            OriginTemplate = origin.Template,
            OriginId = origin.Id,
            EntityPayload = payload,
            EntityTags = origin.Tags,
            IsNatural = isNatural,
            EventLine = eventLine ?? Guid.NewGuid(),
            EventGeneration = eventGeneration,
            State = AppEventState.Pending,
            CreatedDate = DateTime.UtcNow,
            DeferredUntil = DateTime.UtcNow
        };
        
        await EnrichEvent(appEvent);
        await _eventRepo.CreateAsync(transactionContext, appEvent, cancellationToken);
    }
    
    private async Task EnrichEvent(AppEvent appEvent)
    {
        // Add standard metadata
        appEvent.Metadata = JObject.FromObject(new
        {
            machineName = Environment.MachineName,
            processId = Environment.ProcessId,
            threadId = Thread.CurrentThread.ManagedThreadId,
            timestamp = DateTime.UtcNow
        });
        
        // Apply configured enrichers
        foreach (var enricher in _options.Enrichers)
        {
            await enricher.EnrichAsync(appEvent);
        }
    }
}
```

#### AppEventPump
Distributes events from storage to message bus:

```csharp
public class AppEventPump : BackgroundService
{
    private readonly IRepository<AppEvent> _eventRepo;
    private readonly IMessagePublisher _messagePublisher;
    private readonly ApplicationTopologyCatalog _topology;
    private readonly AppEventPumpOptions _options;
    private readonly ILogger<AppEventPump> _logger;
    
    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        // Check if this server should run the pump
        if (!await ShouldRunPump())
        {
            _logger.LogInformation("AppEventPump not enabled for this server role");
            return;
        }
        
        _logger.LogInformation("AppEventPump starting");
        
        while (!stoppingToken.IsCancellationRequested)
        {
            try
            {
                await ProcessPendingEvents(stoppingToken);
                await GroomFailedEvents(stoppingToken);
                
                await Task.Delay(_options.PumpInterval, stoppingToken);
            }
            catch (OperationCanceledException)
            {
                // Expected when cancelling
                break;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error in AppEventPump execution");
                await Task.Delay(TimeSpan.FromSeconds(30), stoppingToken);
            }
        }
        
        _logger.LogInformation("AppEventPump stopped");
    }
    
    private async Task ProcessPendingEvents(CancellationToken cancellationToken)
    {
        var batchSize = _options.BatchSize;
        var processingTimeout = _options.ProcessingTimeout;
        
        // Get pending events
        var (events, _) = await _eventRepo.GetOrderedAsync(
            e => e.State == AppEventState.Pending && 
                 e.DeferredUntil <= DateTime.UtcNow,
            e => e.CreatedDate,
            ascending: true);
            
        if (!events.Any())
        {
            return;
        }
        
        var batch = events.Take(batchSize).ToList();
        
        foreach (var appEvent in batch)
        {
            try
            {
                // Mark as taken
                appEvent.State = AppEventState.Taken;
                appEvent.ProcessorId = Environment.MachineName;
                appEvent.TakenExpiration = DateTime.UtcNow.Add(processingTimeout);
                
                await _eventRepo.UpdateAsync(appEvent, cancellationToken);
                
                // Publish to message bus
                await PublishEvent(appEvent, cancellationToken);
                
                // Mark as completed
                appEvent.State = AppEventState.Completed;
                await _eventRepo.UpdateAsync(appEvent, cancellationToken);
                
                _logger.LogDebug($"Published event {appEvent.Id} with topic {appEvent.Topic}");
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, $"Failed to publish event {appEvent.Id}");
                
                // Mark as failed
                appEvent.State = AppEventState.Failed;
                await _eventRepo.UpdateAsync(appEvent, cancellationToken);
            }
        }
    }
    
    private async Task PublishEvent(AppEvent appEvent, CancellationToken cancellationToken)
    {
        var message = new EventMessage
        {
            EventId = appEvent.Id,
            Topic = appEvent.Topic,
            OriginEntityType = appEvent.OriginEntityType,
            OriginTemplate = appEvent.OriginTemplate,
            OriginId = appEvent.OriginId,
            EventLine = appEvent.EventLine,
            EventGeneration = appEvent.EventGeneration,
            IsNatural = appEvent.IsNatural,
            EntityPayload = appEvent.EntityPayload,
            Tags = appEvent.Tags,
            EntityTags = appEvent.EntityTags,
            CreatedDate = appEvent.CreatedDate,
            Metadata = appEvent.Metadata
        };
        
        await _messagePublisher.SendAsync(message, appEvent.Topic ?? "default");
    }
    
    private async Task GroomFailedEvents(CancellationToken cancellationToken)
    {
        var retryThreshold = DateTime.UtcNow.Subtract(_options.FailedEventRetryInterval);
        
        // Find events that have been taken but expired
        var (expiredEvents, _) = await _eventRepo.GetAsync(
            e => e.State == AppEventState.Taken && 
                 e.TakenExpiration < DateTime.UtcNow);
                 
        foreach (var expiredEvent in expiredEvents)
        {
            // Reset to pending for retry
            expiredEvent.State = AppEventState.Pending;
            expiredEvent.ProcessorId = null;
            expiredEvent.DeferredUntil = DateTime.UtcNow.Add(_options.RetryDelay);
            
            await _eventRepo.UpdateAsync(expiredEvent, cancellationToken);
        }
        
        // Find old failed events for cleanup
        var (oldFailedEvents, _) = await _eventRepo.GetAsync(
            e => e.State == AppEventState.Failed && 
                 e.CreatedDate < retryThreshold);
                 
        foreach (var failedEvent in oldFailedEvents)
        {
            if (_options.DeleteFailedEvents)
            {
                await _eventRepo.DeleteAsync(e => e.Id == failedEvent.Id, cancellationToken);
            }
            else
            {
                failedEvent.State = AppEventState.Cancelled;
                await _eventRepo.UpdateAsync(failedEvent, cancellationToken);
            }
        }
    }
}
```

#### AppEventDistributer
Distributes events to consumers:

```csharp
public class AppEventDistributer : IHostedService
{
    private readonly IMessageListener _messageListener;
    private readonly List<IAppEventConsumer> _consumers;
    private readonly ILogger<AppEventDistributer> _logger;
    
    public Task StartAsync(CancellationToken cancellationToken)
    {
        _messageListener.Initialize("events", "app_events");
        
        // Set up message handling
        _messageListener.Listen(
            new KeyValuePair<Type, Action<object, CancellationToken, IMessageAcknowledge>>(
                typeof(EventMessage),
                (message, ct, ack) => ProcessEventMessage((EventMessage)message, ct, ack)
            )
        );
        
        _logger.LogInformation("AppEventDistributer started");
        return Task.CompletedTask;
    }
    
    private void ProcessEventMessage(
        EventMessage message, 
        CancellationToken cancellationToken,
        IMessageAcknowledge acknowledge)
    {
        _ = Task.Run(async () =>
        {
            try
            {
                var appEvent = new AppEvent
                {
                    Id = message.EventId,
                    Topic = message.Topic,
                    OriginEntityType = message.OriginEntityType,
                    OriginTemplate = message.OriginTemplate,
                    OriginId = message.OriginId,
                    EventLine = message.EventLine,
                    EventGeneration = message.EventGeneration,
                    IsNatural = message.IsNatural,
                    EntityPayload = message.EntityPayload,
                    Tags = message.Tags,
                    EntityTags = message.EntityTags,
                    CreatedDate = message.CreatedDate,
                    Metadata = message.Metadata
                };
                
                // Distribute to all consumers
                foreach (var consumer in _consumers)
                {
                    try
                    {
                        consumer.ConsumeEvents(appEvent);
                    }
                    catch (Exception ex)
                    {
                        _logger.LogError(ex, $"Consumer {consumer.GetType().Name} failed to process event {appEvent.Id}");
                    }
                }
                
                acknowledge.Ack();
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, $"Failed to process event message {message.EventId}");
                acknowledge.Nack(requeue: true);
            }
        }, cancellationToken);
    }
    
    public Task StopAsync(CancellationToken cancellationToken)
    {
        _messageListener?.Dispose();
        _logger.LogInformation("AppEventDistributer stopped");
        return Task.CompletedTask;
    }
}
```

### Event Examples

#### Creating Application Events
```csharp
public class EventExamples
{
    // User lifecycle events
    public static async Task DemonstrateUserEvents()
    {
        // User registration
        await _eventSink.SinkAsync(
            topic: "User.Registered",
            origin: AppEventOrigin.FromEntity(user),
            payload: user.ToBsonDocument(),
            isNatural: true
        );
        
        // Email verification
        await _eventSink.SinkAsync(
            topic: "User.EmailVerified",
            origin: AppEventOrigin.FromEntity(user),
            payload: BsonDocument.Parse(JsonConvert.SerializeObject(new
            {
                userId = user.Id,
                email = user.Email,
                verifiedAt = DateTime.UtcNow
            })),
            isNatural: false // System generated
        );
        
        // User login
        await _eventSink.SinkAsync(
            topic: "User.LoggedIn",
            origin: AppEventOrigin.FromEntity(user),
            payload: BsonDocument.Parse(JsonConvert.SerializeObject(new
            {
                userId = user.Id,
                loginTime = DateTime.UtcNow,
                ipAddress = "192.168.1.100",
                userAgent = "Mozilla/5.0...",
                sessionId = Guid.NewGuid()
            }))
        );
    }
    
    // Business process events
    public static async Task DemonstrateBusinessProcessEvents()
    {
        // Order processing workflow
        var order = new Order { Id = Guid.NewGuid(), CustomerId = Guid.NewGuid() };
        var eventLine = Guid.NewGuid(); // Group related events
        
        // Order created
        await _eventSink.SinkAsync(
            topic: "Order.Created",
            origin: new AppEventOrigin 
            { 
                EntityType = "Order", 
                Id = order.Id 
            },
            payload: order.ToBsonDocument(),
            eventLine: eventLine,
            eventGeneration: 0
        );
        
        // Payment processed (child event)
        await _eventSink.SinkAsync(
            topic: "Order.PaymentProcessed",
            origin: new AppEventOrigin 
            { 
                EntityType = "Order", 
                Id = order.Id 
            },
            payload: BsonDocument.Parse(JsonConvert.SerializeObject(new
            {
                orderId = order.Id,
                amount = 99.99,
                paymentMethod = "CreditCard",
                transactionId = "TXN-12345"
            })),
            eventLine: eventLine,
            eventGeneration: 1
        );
        
        // Inventory updated (child event)
        await _eventSink.SinkAsync(
            topic: "Inventory.Updated",
            origin: new AppEventOrigin 
            { 
                EntityType = "Order", 
                Id = order.Id 
            },
            payload: BsonDocument.Parse(JsonConvert.SerializeObject(new
            {
                orderId = order.Id,
                items = new[]
                {
                    new { productId = "PROD-001", quantity = 2 },
                    new { productId = "PROD-002", quantity = 1 }
                }
            })),
            eventLine: eventLine,
            eventGeneration: 1
        );
        
        // Order fulfilled (child event)
        await _eventSink.SinkAsync(
            topic: "Order.Fulfilled",
            origin: new AppEventOrigin 
            { 
                EntityType = "Order", 
                Id = order.Id 
            },
            payload: BsonDocument.Parse(JsonConvert.SerializeObject(new
            {
                orderId = order.Id,
                fulfilledAt = DateTime.UtcNow,
                trackingNumber = "TRACK-98765",
                carrier = "UPS"
            })),
            eventLine: eventLine,
            eventGeneration: 2
        );
    }
}
```

### Best Practices

1. **Use meaningful topic hierarchies** - Structure topics logically (Entity.Action)
2. **Include sufficient event data** - Balance completeness with performance
3. **Implement proper correlation** - Use EventLine for related events
4. **Handle failures gracefully** - Implement retry and dead letter patterns
5. **Monitor event processing** - Track throughput and latency
6. **Keep events immutable** - Never modify event data after creation
7. **Design for idempotency** - Handle duplicate event processing
8. **Use natural vs system flags** - Distinguish user actions from system events
9. **Implement event versioning** - Handle schema evolution
10. **Archive old events** - Manage storage growth over time

---

## Authorization System

The Authorization System provides comprehensive authentication and authorization capabilities built on ASP.NET Core Identity with MongoDB persistence. It includes JWT token management, role-based authorization, user invitation workflows, and secure password handling.

### Core Components

#### ApplicationUser
The primary user entity extending MongoDB Identity:

```csharp
[CollectionName("ApplicationUsers")]
public class ApplicationUser : MongoIdentityUser<Guid>, IDataModel
{
    public string? TimeZoneId { get; set; }        // User timezone
    public List<string> Tags { get; set; } = new(); // User categorization tags
    
    public ApplicationUser() : base() { }
    
    public ApplicationUser(string userName, string email, string tzid) 
        : base(userName, email)
    {
        TimeZoneId = tzid;
    }
}
```

#### ApplicationRole
Role entity for role-based access control:

```csharp
[CollectionName("ApplicationRoles")]
public class ApplicationRole : MongoIdentityRole<Guid>, IDataModel
{
    public ApplicationRole() : base() { }
    
    public ApplicationRole(string roleName) : base(roleName) { }
}
```

#### JwtComponent
Manages JWT token generation, validation, and refresh:

```csharp
public class JwtComponent
{
    private readonly JwtConfig _jwtConfig;
    private readonly IRepository<RefreshToken> _jwtRepository;
    private readonly TokenValidationParameters _tokenValidationParameters;
    private readonly CustomUserManager _userManager;
    private readonly CustomRoleManager _roleManager;
    
    // Generate JWT token with claims
    public async Task<AuthResponse> GenerateJwtToken(ApplicationUser user)
    {
        var jwtTokenHandler = new JwtSecurityTokenHandler();
        var key = Encoding.ASCII.GetBytes(_jwtConfig.Secret);
        
        var userClaims = await AssembleClaimsAsync(user);
        
        var tokenDescriptor = new SecurityTokenDescriptor
        {
            Subject = new ClaimsIdentity(userClaims),
            Expires = DateTime.UtcNow.AddSeconds(600.0), // 10 minutes
            SigningCredentials = new SigningCredentials(
                new SymmetricSecurityKey(key), 
                SecurityAlgorithms.HmacSha256Signature)
        };
        
        var token = jwtTokenHandler.CreateToken(tokenDescriptor);
        var jwtToken = jwtTokenHandler.WriteToken(token);
        
        // Create refresh token
        var refreshToken = new RefreshToken
        {
            JwtId = token.Id,
            IsUsed = false,
            IsRevoked = false,
            UserId = user.Id,
            Added = DateTime.UtcNow,
            ExpiryDate = DateTime.UtcNow.AddMonths(6),
            Token = GoodSeedRandom.RandomString(35) + Guid.NewGuid()
        };
        
        await _jwtRepository.CreateAsync(refreshToken);
        
        return new AuthResponse
        {
            Token = jwtToken,
            RefreshToken = refreshToken.Token,
            Roles = user.Roles.Select(r => r.ToString()).ToList()
        };
    }
    
    // Assemble user claims including roles and permissions
    private async Task<List<Claim>> AssembleClaimsAsync(ApplicationUser user)
    {
        var claims = new List<Claim>
        {
            new Claim("Id", user.Id.ToString()),
            new Claim(ClaimTypes.NameIdentifier, user.Id.ToString()),
            new Claim(JwtRegisteredClaimNames.NameId, user.Id.ToString()),
            new Claim(JwtRegisteredClaimNames.Email, user.Email),
            new Claim(JwtRegisteredClaimNames.Sub, user.Email),
            new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString())
        };
        
        // Add existing user claims
        var userClaims = await _userManager.GetClaimsAsync(user);
        claims.AddRange(userClaims);
        
        // Add role claims
        var userRoles = await _userManager.GetRolesAsync(user);
        foreach (var userRole in userRoles)
        {
            claims.Add(new Claim(ClaimTypes.Role, userRole.ToString()));
            
            var role = await _roleManager.FindByNameAsync(userRole.ToString());
            if (role != null)
            {
                var roleClaims = await _roleManager.GetClaimsAsync(role);
                foreach (var roleClaim in roleClaims)
                {
                    claims.Add(new Claim(roleClaim.Type, roleClaim.Value));
                }
            }
        }
        
        return claims;
    }
    
    // Refresh expired tokens
    public async Task<AuthResponse> RefreshToken(TokenRequest request)
    {
        // Validate token structure and expiration
        // Verify refresh token exists and is valid
        // Generate new token pair
        return await VerifyAndGenerateToken(request);
    }
}
```

#### LoginLogic
Handles user authentication operations:

```csharp
public class LoginLogic
{
    private readonly JwtComponent _jwt;
    private readonly CustomUserManager _userManager;
    private readonly CustomSignInManager _signInManager;
    
    public async Task<AuthResponse> Login(string email, string password)
    {
        email.Requires().IsNotNullOrEmpty();
        password.Requires().IsNotNullOrEmpty();
        
        var user = await _userManager.FindByEmailAsync(email);
        user.Guarantees("Login failed: Email or password incorrect.").IsNotNull();
        
        var result = await _signInManager.PasswordSignInAsync(user, password, false, false);
        result.Succeeded.Guarantees("Login failed: Email or password incorrect.").IsTrue();
        
        return await _jwt.GenerateJwtToken(user);
    }
    
    public async Task Logout(ApplicationUser user, string returnUrl)
    {
        await _signInManager.SignOutAsync(user, returnUrl);
    }
    
    public async Task<AuthResponse> Refresh(TokenRequest tokenRequest)
    {
        return await _jwt.RefreshToken(tokenRequest);
    }
}
```

#### InvitationLogic
Manages user invitation workflow:

```csharp
public class InvitationLogic
{
    private readonly IRepository<InvitationDataModel> _invitationRepository;
    private readonly CustomUserManager _userManager;
    private readonly IRegulatedNotificationLogic _notificationLogic;
    
    public async Task<InvitationDataModel> CreateInvitation(
        string email,
        List<string> roles,
        Guid invitedBy,
        DateTime? expirationDate = null)
    {
        var invitation = new InvitationDataModel
        {
            Email = email.ToLowerInvariant(),
            Roles = roles,
            InvitedBy = invitedBy,
            InvitationToken = Guid.NewGuid().ToString(),
            ExpirationDate = expirationDate ?? DateTime.UtcNow.AddDays(7),
            Status = InvitationStatus.Pending,
            CreatedDate = DateTime.UtcNow
        };
        
        await _invitationRepository.CreateAsync(invitation);
        
        // Send invitation email
        await _notificationLogic.RequestNotification(new RequestNotification
        {
            ToEmail = email,
            Subject = "You've been invited to join our platform",
            EmailText = $"Click here to accept your invitation: /accept-invitation/{invitation.InvitationToken}",
            Tags = new[] { "invitation", "onboarding" }
        });
        
        return invitation;
    }
    
    public async Task<ApplicationUser> AcceptInvitation(
        string token,
        string password,
        string firstName,
        string lastName)
    {
        var invitation = await GetValidInvitation(token);
        
        // Create user account
        var user = new ApplicationUser(invitation.Email, invitation.Email, "UTC")
        {
            FirstName = firstName,
            LastName = lastName,
            EmailConfirmed = true
        };
        
        var result = await _userManager.CreateAsync(user, password);
        if (!result.Succeeded)
        {
            throw new ValidationException("Failed to create user account");
        }
        
        // Assign roles
        foreach (var role in invitation.Roles)
        {
            await _userManager.AddToRoleAsync(user, role);
        }
        
        // Mark invitation as accepted
        invitation.Status = InvitationStatus.Accepted;
        invitation.AcceptedDate = DateTime.UtcNow;
        invitation.AcceptedByUserId = user.Id;
        await _invitationRepository.UpdateAsync(invitation);
        
        return user;
    }
}
```

#### CustomUserManager
Extended user manager with additional functionality:

```csharp
public class CustomUserManager : UserManager<ApplicationUser>
{
    private readonly IRepository<ApplicationUser> _userRepository;
    private readonly IRepository<UserTagsDataModel> _userTagsRepository;
    
    public async Task<ApplicationUser> FindByEmailAsync(string email, CancellationToken ct = default)
    {
        var (users, _) = await _userRepository.GetAsync(u => u.Email == email.ToLowerInvariant(), ct);
        return users.FirstOrDefault();
    }
    
    public async Task<IdentityResult> CreateAsync(ApplicationUser user, string password)
    {
        // Hash password
        user.PasswordHash = _passwordHasher.HashPassword(user, password);
        user.SecurityStamp = Guid.NewGuid().ToString();
        user.CreatedDate = DateTime.UtcNow;
        user.UpdatedDate = DateTime.UtcNow;
        
        try
        {
            await _userRepository.CreateAsync(user);
            return IdentityResult.Success;
        }
        catch (Exception ex)
        {
            return IdentityResult.Failed(new IdentityError
            {
                Code = "CreateUserFailed",
                Description = ex.Message
            });
        }
    }
    
    public async Task<bool> CheckPasswordAsync(ApplicationUser user, string password)
    {
        var result = _passwordHasher.VerifyHashedPassword(user, user.PasswordHash, password);
        return result == PasswordVerificationResult.Success;
    }
    
    public async Task AddTagsAsync(Guid userId, params string[] tags)
    {
        var userTags = new UserTagsDataModel
        {
            UserId = userId,
            Tags = tags.ToList(),
            AddedDate = DateTime.UtcNow
        };
        
        await _userTagsRepository.CreateAsync(userTags);
    }
}
```

#### AuthResponse and Supporting Models
Authentication response and supporting data models:

```csharp
public class AuthResponse
{
    public string Token { get; set; }              // JWT access token
    public string RefreshToken { get; set; }       // Refresh token
    public List<string> Roles { get; set; }        // User roles
    public bool Success { get; set; } = true;      // Operation success
    public List<string> Errors { get; set; } = new(); // Error messages
}

public class TokenRequest
{
    public string Token { get; set; }              // Expired JWT token
    public string RefreshToken { get; set; }       // Refresh token
}

public class RefreshToken : IDataModel
{
    public Guid Id { get; set; }
    public int Version { get; set; }
    public string JwtId { get; set; }              // JWT token ID
    public string Token { get; set; }              // Refresh token value
    public bool IsUsed { get; set; }               // Token usage status
    public bool IsRevoked { get; set; }            // Token revocation status
    public Guid UserId { get; set; }               // Associated user
    public DateTime Added { get; set; }            // Creation date
    public DateTime ExpiryDate { get; set; }       // Expiration date
}

public class InvitationDataModel : IDataModel
{
    public Guid Id { get; set; }
    public int Version { get; set; }
    public string Email { get; set; }              // Invited email
    public List<string> Roles { get; set; }        // Assigned roles
    public Guid InvitedBy { get; set; }            // Inviting user
    public string InvitationToken { get; set; }    // Unique invitation token
    public InvitationStatus Status { get; set; }   // Invitation status
    public DateTime CreatedDate { get; set; }      // Creation timestamp
    public DateTime ExpirationDate { get; set; }   // Expiration timestamp
    public DateTime? AcceptedDate { get; set; }    // Acceptance timestamp
    public Guid? AcceptedByUserId { get; set; }    // Accepting user
}

public enum InvitationStatus
{
    Pending = 0,
    Accepted = 1,
    Expired = 2,
    Revoked = 3
}
```

### Service Registration and Configuration

#### Dependency Injection Setup
```csharp
public static class AuthorizationServiceExtensions
{
    public static IServiceCollection AddBFormAuthorization(
        this IServiceCollection services, 
        IConfiguration configuration)
    {
        // JWT Configuration
        var jwtConfig = new JwtConfig();
        configuration.Bind("JwtConfig", jwtConfig);
        services.Configure<JwtConfig>(configuration.GetSection("JwtConfig"));
        
        // Token validation parameters
        var tokenValidationParameters = new TokenValidationParameters
        {
            ValidateIssuerSigningKey = true,
            IssuerSigningKey = new SymmetricSecurityKey(Encoding.ASCII.GetBytes(jwtConfig.Secret)),
            ValidateIssuer = false,
            ValidateAudience = false,
            RequireExpirationTime = false,
            ValidateLifetime = true,
            ClockSkew = TimeSpan.Zero
        };
        services.AddSingleton(tokenValidationParameters);
        
        // Identity services
        services.AddIdentityCore<ApplicationUser>(options =>
        {
            options.Password.RequireDigit = true;
            options.Password.RequiredLength = 8;
            options.Password.RequireNonAlphanumeric = true;
            options.Password.RequireUppercase = true;
            options.Password.RequireLowercase = true;
            options.User.RequireUniqueEmail = true;
        })
        .AddRoles<ApplicationRole>()
        .AddMongoDbStores<ApplicationUser, ApplicationRole, Guid>(
            configuration.GetConnectionString("MongoDB"));
        
        // Custom managers
        services.AddScoped<CustomUserManager>();
        services.AddScoped<CustomRoleManager>();
        services.AddScoped<CustomSignInManager>();
        
        // Business logic services
        services.AddScoped<JwtComponent>();
        services.AddScoped<LoginLogic>();
        services.AddScoped<RegistrationLogic>();
        services.AddScoped<InvitationLogic>();
        services.AddScoped<UserManagementLogic>();
        
        // JWT Authentication
        services.AddAuthentication(options =>
        {
            options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
            options.DefaultScheme = JwtBearerDefaults.AuthenticationScheme;
            options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;
        })
        .AddJwtBearer(jwt =>
        {
            jwt.SaveToken = true;
            jwt.TokenValidationParameters = tokenValidationParameters;
        });
        
        return services;
    }
}
```

### Security Features

#### Password Security
- **BCrypt Hashing**: Strong password hashing using BCrypt
- **Password Requirements**: Configurable complexity requirements
- **Salt Generation**: Automatic salt generation for each password
- **Verification**: Secure password verification

#### Token Security
- **Short-lived Access Tokens**: 10-minute JWT expiration
- **Long-lived Refresh Tokens**: 6-month refresh token lifetime
- **Token Rotation**: New tokens generated on refresh
- **Revocation Support**: Ability to revoke refresh tokens
- **Signature Validation**: HMAC-SHA256 signature verification

#### Role-Based Authorization
- **Hierarchical Roles**: Support for role inheritance
- **Claims-Based Authorization**: Fine-grained permissions via claims
- **Dynamic Role Assignment**: Runtime role management
- **Role Scoping**: Context-specific role application

### Usage Examples

#### User Registration and Login
```csharp
public class AuthController : ControllerBase
{
    private readonly LoginLogic _loginLogic;
    private readonly RegistrationLogic _registrationLogic;
    
    [HttpPost("register")]
    public async Task<IActionResult> Register(RegisterRequest request)
    {
        try
        {
            var user = await _registrationLogic.RegisterUser(
                request.Email,
                request.Password,
                request.FirstName,
                request.LastName,
                request.TimeZoneId
            );
            
            var authResponse = await _loginLogic.Login(request.Email, request.Password);
            return Ok(authResponse);
        }
        catch (ValidationException ex)
        {
            return BadRequest(new { errors = new[] { ex.Message } });
        }
    }
    
    [HttpPost("login")]
    public async Task<IActionResult> Login(LoginRequest request)
    {
        try
        {
            var authResponse = await _loginLogic.Login(request.Email, request.Password);
            return Ok(authResponse);
        }
        catch (ValidationException ex)
        {
            return Unauthorized(new { errors = new[] { ex.Message } });
        }
    }
    
    [HttpPost("refresh")]
    public async Task<IActionResult> RefreshToken(TokenRequest request)
    {
        try
        {
            var authResponse = await _loginLogic.Refresh(request);
            return Ok(authResponse);
        }
        catch (ValidationException ex)
        {
            return BadRequest(new { errors = new[] { ex.Message } });
        }
    }
}
```

#### User Invitation Workflow
```csharp
public class InvitationController : ControllerBase
{
    private readonly InvitationLogic _invitationLogic;
    
    [HttpPost("invite")]
    [Authorize(Roles = "Admin,Manager")]
    public async Task<IActionResult> InviteUser(InviteRequest request)
    {
        var currentUserId = User.GetUserId();
        
        var invitation = await _invitationLogic.CreateInvitation(
            email: request.Email,
            roles: request.Roles,
            invitedBy: currentUserId,
            expirationDate: DateTime.UtcNow.AddDays(7)
        );
        
        return Ok(new { invitationId = invitation.Id });
    }
    
    [HttpPost("accept-invitation/{token}")]
    public async Task<IActionResult> AcceptInvitation(
        string token, 
        AcceptInvitationRequest request)
    {
        try
        {
            var user = await _invitationLogic.AcceptInvitation(
                token,
                request.Password,
                request.FirstName,
                request.LastName
            );
            
            var authResponse = await _loginLogic.Login(user.Email, request.Password);
            return Ok(authResponse);
        }
        catch (ValidationException ex)
        {
            return BadRequest(new { errors = new[] { ex.Message } });
        }
    }
}
```

#### Role Management
```csharp
public class RoleManagementExample
{
    private readonly CustomUserManager _userManager;
    private readonly CustomRoleManager _roleManager;
    
    public async Task AssignUserRoles(Guid userId, params string[] roleNames)
    {
        var user = await _userManager.FindByIdAsync(userId.ToString());
        
        foreach (var roleName in roleNames)
        {
            if (await _roleManager.RoleExistsAsync(roleName))
            {
                await _userManager.AddToRoleAsync(user, roleName);
            }
        }
    }
    
    public async Task CreateRoleWithClaims(string roleName, params string[] permissions)
    {
        var role = new ApplicationRole(roleName);
        await _roleManager.CreateAsync(role);
        
        foreach (var permission in permissions)
        {
            await _roleManager.AddClaimAsync(role, new Claim("permission", permission));
        }
    }
}
```

#### Authorization Attributes
```csharp
[Authorize(Roles = "Admin")]
public class AdminController : ControllerBase
{
    [HttpGet("users")]
    public async Task<IActionResult> GetAllUsers()
    {
        // Only accessible to Admin role
    }
}

[Authorize]
[RequireClaim("permission", "CanViewReports")]
public class ReportsController : ControllerBase
{
    [HttpGet]
    public async Task<IActionResult> GetReports()
    {
        // Requires specific permission claim
    }
}
```

### Best Practices

1. **Always use HTTPS** - Protect tokens in transit
2. **Implement token rotation** - Regularly refresh access tokens
3. **Use short token lifetimes** - Minimize exposure window
4. **Validate all inputs** - Use the validation framework
5. **Log security events** - Monitor authentication attempts
6. **Implement rate limiting** - Prevent brute force attacks
7. **Use strong passwords** - Enforce password complexity
8. **Secure token storage** - Store refresh tokens securely
9. **Implement proper logout** - Revoke tokens on logout
10. **Monitor for anomalies** - Track unusual access patterns

---

## Scheduler System

The Scheduler System provides comprehensive job scheduling capabilities with support for one-time execution, recurring schedules, and cron expressions. It integrates with the AppEvents system to trigger scheduled operations and supports multiple schedule types for flexible timing requirements.

### Core Components

#### ScheduledEventTemplate
Defines the structure and timing for scheduled events:

```csharp
public class ScheduledEventTemplate : IContentType
{
    public string Name { get; set; }                    // Unique identifier
    public List<string> Tags { get; set; } = new();     // Categorization tags
    public Dictionary<string, string>? SatelliteData { get; set; } = new();
    
    // Event configuration
    public string EventTopic { get; set; }              // Last part of event topic
    
    // Schedule specification - supports multiple formats:
    // "ts:{timespan}" - One-time execution after timespan
    // "rf:{timespan}" - Repeat forever with timespan interval
    // "rc:{timespan}|{count}" - Repeat specified count with timespan
    // "cr:{cron}" - Cron expression scheduling
    public string Schedule { get; set; }
    
    public ScheduledEventIdentifier CreateIdentifier(Guid schId)
    {
        var group = $"{Name}.{EventTopic}";
        var id = GuidEncoder.Encode(schId);
        return new ScheduledEventIdentifier(nameof(ScheduledEvent), id, group, id);
    }
    
    public string CreateEventTopic(string wsTemplateName, string wiTemplateName)
    {
        return $"{wsTemplateName}.{wiTemplateName}.scheduled.event.{EventTopic.ToLowerInvariant()}";
    }
}
```

#### CronExpression
Handles cron expression parsing and evaluation:

```csharp
public class CronExpression
{
    private CrontabSchedule _schedule;
    
    public CronExpression(string cronExpression)
    {
        try
        {
            _schedule = CrontabSchedule.Parse(cronExpression);
        }
        catch (Exception ex)
        {
            throw new ArgumentException("Invalid cron expression.", ex);
        }
    }
    
    public TimeStatus CheckStatus(
        DateTime currentUtcDateTime,
        TimeZoneInfo timeZone,
        DateTime? previousInvocationTime)
    {
        DateTime currentLocalDateTime = TimeZoneInfo.ConvertTimeFromUtc(currentUtcDateTime, timeZone);
        DateTime? previousLocalInvocationTime = previousInvocationTime.HasValue
            ? TimeZoneInfo.ConvertTimeFromUtc(previousInvocationTime.Value, timeZone)
            : (DateTime?)null;
        
        DateTime nextOccurrence = _schedule.GetNextOccurrence(
            previousLocalInvocationTime ?? DateTime.MinValue);
        
        if (nextOccurrence <= currentLocalDateTime)
        {
            if (previousLocalInvocationTime.HasValue && 
                previousLocalInvocationTime.Value == nextOccurrence)
            {
                return TimeStatus.NotDue;
            }
            return TimeStatus.Overdue;
        }
        
        return TimeStatus.NotDue;
    }
    
    public enum TimeStatus
    {
        Due = 0,
        NotDue = 1,
        Overdue = 2
    }
}
```

#### SchedulerBackgroundWorker
Background service that processes scheduled jobs:

```csharp
public class SchedulerBackgroundWorker : BackgroundService
{
    private readonly IRepository<ScheduledJobEntity> _repo;
    private readonly AppEventSink _eventSink;
    
    public SchedulerBackgroundWorker(
        IRepository<ScheduledJobEntity> repo,
        AppEventSink eventSink)
    {
        _repo = repo;
        _eventSink = eventSink;
    }
    
    protected override Task ExecuteAsync(CancellationToken stoppingToken)
    {
        var task = new Task(async () =>
        {
            while (!stoppingToken.IsCancellationRequested)
            {
                await ScheduleJobs();
                Thread.Yield();
            }
        });
        
        task.Start();
        return Task.CompletedTask;
    }
    
    private async Task ScheduleJobs()
    {
        var (schedules, ctx) = await _repo.GetOrderedAsync(
            sch => sch.NextDeadline,
            descending: true,
            start: 0,
            count: 1000);
        
        foreach (var schedule in schedules)
        {
            if (schedule.NextDeadline < DateTime.UtcNow)
            {
                bool scheduleDone = await ProcessSchedule(schedule, ctx);
                
                if (scheduleDone)
                {
                    await _repo.DeleteAsync((schedule, ctx));
                }
                else
                {
                    await UpdateNextDeadline(schedule, ctx);
                }
                
                // Send event to trigger scheduled operation
                await TriggerScheduledEvent(schedule);
            }
        }
    }
    
    private async Task<bool> ProcessSchedule(ScheduledJobEntity schedule, RepositoryContext ctx)
    {
        switch (schedule.Payload.Type)
        {
            case ScheduleType.Once:
                return true; // One-time execution, mark as done
                
            case ScheduleType.RecurringX:
                schedule.Payload.InvocationCount++;
                return schedule.Payload.InvocationCount >= schedule.Payload.RecurrenceCount;
                
            case ScheduleType.RecurringInfinite:
                schedule.Payload.InvocationCount++;
                return false; // Never stops
                
            case ScheduleType.Cron:
                return false; // Cron schedules continue indefinitely
                
            default:
                return false;
        }
    }
    
    private async Task UpdateNextDeadline(ScheduledJobEntity schedule, RepositoryContext ctx)
    {
        if (!string.IsNullOrWhiteSpace(schedule.Payload.CronExpression))
        {
            var cron = CrontabSchedule.Parse(schedule.Payload.CronExpression);
            schedule.NextDeadline = cron.GetNextOccurrence(DateTime.UtcNow);
        }
        else
        {
            schedule.NextDeadline = DateTime.UtcNow + schedule.RecurrenceSchedule;
        }
        
        await _repo.UpdateAsync((schedule, ctx));
    }
    
    private async Task TriggerScheduledEvent(ScheduledJobEntity schedule)
    {
        var handle = _repo.OpenTransaction();
        _eventSink.BeginBatch(handle);
        
        await _eventSink.Enqueue(
            new AppEventOrigin(nameof(SchedulerBackgroundWorker), nameof(ScheduleJobs), null),
            schedule.Payload.Topic,
            nameof(ScheduleJobs),
            schedule,
            null,
            null);
        
        await _eventSink.CommitBatch();
    }
}
```

#### ScheduledJobEntity
Represents a scheduled job in the system:

```csharp
public class ScheduledJobEntity : IDataModel
{
    public Guid Id { get; set; }
    public int Version { get; set; }
    
    // Scheduling information
    public DateTime NextDeadline { get; set; }           // When job should run next
    public TimeSpan RecurrenceSchedule { get; set; }     // Interval for recurring jobs
    
    // Job configuration
    public Schedule Payload { get; set; }                // Job details and parameters
    
    // Execution tracking
    public DateTime? LastExecuted { get; set; }          // Last execution time
    public int ExecutionCount { get; set; }              // Total executions
    public ScheduleStatus Status { get; set; }           // Current status
}

public class Schedule
{
    public ScheduleType Type { get; set; }               // Schedule type
    public string Topic { get; set; }                    // Event topic to trigger
    public string? CronExpression { get; set; }          // Cron expression (if applicable)
    public int InvocationCount { get; set; }             // Current invocation count
    public int RecurrenceCount { get; set; }             // Max recurrences (for RecurringX)
    public JObject? Parameters { get; set; }             // Job parameters
    public List<string> Tags { get; set; } = new();      // Job tags
}

public enum ScheduleType
{
    Once = 0,              // Execute once
    RecurringX = 1,        // Execute X times
    RecurringInfinite = 2, // Execute forever
    Cron = 3               // Use cron expression
}

public enum ScheduleStatus
{
    Active = 0,
    Paused = 1,
    Completed = 2,
    Failed = 3,
    Cancelled = 4
}
```

#### SinkEventJob
Specific job type for sinking events:

```csharp
public class SinkEventJob
{
    public string EventTopic { get; set; }               // Topic to sink to
    public JObject EventPayload { get; set; }            // Event data
    public AppEventOrigin Origin { get; set; }           // Event origin
    public List<string> Tags { get; set; } = new();      // Event tags
    public int Priority { get; set; } = 0;               // Event priority
    
    public async Task Execute(AppEventSink eventSink)
    {
        await eventSink.SinkAsync(
            topic: EventTopic,
            origin: Origin,
            payload: BsonDocument.Parse(EventPayload.ToString()),
            tags: Tags.ToArray(),
            priority: Priority);
    }
}
```

#### SchedulerLogic
Business logic for schedule management:

```csharp
public class SchedulerLogic
{
    private readonly IRepository<ScheduledJobEntity> _scheduleRepository;
    private readonly AppEventSink _eventSink;
    
    public async Task<ScheduledJobEntity> CreateSchedule(
        string topic,
        string scheduleExpression,
        JObject? parameters = null,
        string[]? tags = null)
    {
        var schedule = ParseScheduleExpression(scheduleExpression);
        
        var scheduledJob = new ScheduledJobEntity
        {
            Payload = new Schedule
            {
                Type = schedule.Type,
                Topic = topic,
                CronExpression = schedule.CronExpression,
                RecurrenceCount = schedule.RecurrenceCount,
                Parameters = parameters,
                Tags = tags?.ToList() ?? new List<string>()
            },
            NextDeadline = CalculateNextDeadline(schedule),
            RecurrenceSchedule = schedule.Interval,
            Status = ScheduleStatus.Active
        };
        
        return await _scheduleRepository.CreateAsync(scheduledJob);
    }
    
    public async Task<ScheduledJobEntity> CreateOneTimeSchedule(
        string topic,
        DateTime executeAt,
        JObject? parameters = null)
    {
        var scheduledJob = new ScheduledJobEntity
        {
            Payload = new Schedule
            {
                Type = ScheduleType.Once,
                Topic = topic,
                Parameters = parameters
            },
            NextDeadline = executeAt,
            Status = ScheduleStatus.Active
        };
        
        return await _scheduleRepository.CreateAsync(scheduledJob);
    }
    
    public async Task<ScheduledJobEntity> CreateRecurringSchedule(
        string topic,
        TimeSpan interval,
        int? maxExecutions = null,
        JObject? parameters = null)
    {
        var scheduledJob = new ScheduledJobEntity
        {
            Payload = new Schedule
            {
                Type = maxExecutions.HasValue ? ScheduleType.RecurringX : ScheduleType.RecurringInfinite,
                Topic = topic,
                RecurrenceCount = maxExecutions ?? 0,
                Parameters = parameters
            },
            NextDeadline = DateTime.UtcNow.Add(interval),
            RecurrenceSchedule = interval,
            Status = ScheduleStatus.Active
        };
        
        return await _scheduleRepository.CreateAsync(scheduledJob);
    }
    
    public async Task<ScheduledJobEntity> CreateCronSchedule(
        string topic,
        string cronExpression,
        JObject? parameters = null)
    {
        var cron = CrontabSchedule.Parse(cronExpression);
        
        var scheduledJob = new ScheduledJobEntity
        {
            Payload = new Schedule
            {
                Type = ScheduleType.Cron,
                Topic = topic,
                CronExpression = cronExpression,
                Parameters = parameters
            },
            NextDeadline = cron.GetNextOccurrence(DateTime.UtcNow),
            Status = ScheduleStatus.Active
        };
        
        return await _scheduleRepository.CreateAsync(scheduledJob);
    }
    
    private (ScheduleType Type, string? CronExpression, TimeSpan Interval, int RecurrenceCount) 
        ParseScheduleExpression(string expression)
    {
        if (expression.StartsWith("ts:"))
        {
            var timespan = TimeSpan.Parse(expression.Substring(3));
            return (ScheduleType.Once, null, timespan, 0);
        }
        else if (expression.StartsWith("rf:"))
        {
            var timespan = TimeSpan.Parse(expression.Substring(3));
            return (ScheduleType.RecurringInfinite, null, timespan, 0);
        }
        else if (expression.StartsWith("rc:"))
        {
            var parts = expression.Substring(3).Split('|');
            var timespan = TimeSpan.Parse(parts[0]);
            var count = int.Parse(parts[1]);
            return (ScheduleType.RecurringX, null, timespan, count);
        }
        else if (expression.StartsWith("cr:"))
        {
            var cronExpression = expression.Substring(3);
            return (ScheduleType.Cron, cronExpression, TimeSpan.Zero, 0);
        }
        
        throw new ArgumentException($"Invalid schedule expression: {expression}");
    }
}
```

### Schedule Expression Formats

The system supports four schedule expression formats:

#### 1. One-time Execution (`ts:`)
```csharp
// Execute once after 30 minutes
"ts:00:30:00"

// Execute once after 2 hours
"ts:02:00:00"

// Execute once after 1 day
"ts:1.00:00:00"
```

#### 2. Infinite Recurrence (`rf:`)
```csharp
// Repeat every 15 minutes forever
"rf:00:15:00"

// Repeat every hour forever
"rf:01:00:00"

// Repeat every day forever
"rf:1.00:00:00"
```

#### 3. Limited Recurrence (`rc:`)
```csharp
// Repeat every 30 minutes, 10 times total
"rc:00:30:00|10"

// Repeat every 2 hours, 5 times total
"rc:02:00:00|5"

// Repeat daily, 30 times total
"rc:1.00:00:00|30"
```

#### 4. Cron Expression (`cr:`)
```csharp
// Every day at 2:30 AM
"cr:30 2 * * *"

// Every Monday at 9:00 AM
"cr:0 9 * * 1"

// Every 15 minutes during business hours (9-5, Mon-Fri)
"cr:*/15 9-17 * * 1-5"

// First day of every month at midnight
"cr:0 0 1 * *"
```

### Usage Examples

#### Creating Different Schedule Types
```csharp
public class SchedulingExamples
{
    private readonly SchedulerLogic _schedulerLogic;
    
    // One-time reminder
    public async Task ScheduleReminder()
    {
        await _schedulerLogic.CreateOneTimeSchedule(
            topic: "User.Reminder",
            executeAt: DateTime.UtcNow.AddHours(24),
            parameters: JObject.FromObject(new
            {
                userId = Guid.NewGuid(),
                message = "Don't forget your appointment tomorrow!",
                type = "appointment"
            }));
    }
    
    // Daily backup
    public async Task ScheduleDailyBackup()
    {
        await _schedulerLogic.CreateCronSchedule(
            topic: "System.Backup",
            cronExpression: "0 2 * * *", // Every day at 2 AM
            parameters: JObject.FromObject(new
            {
                backupType = "full",
                retentionDays = 30
            }));
    }
    
    // Recurring health check
    public async Task ScheduleHealthCheck()
    {
        await _schedulerLogic.CreateRecurringSchedule(
            topic: "System.HealthCheck",
            interval: TimeSpan.FromMinutes(5),
            maxExecutions: null, // Infinite
            parameters: JObject.FromObject(new
            {
                checkServices = new[] { "database", "cache", "messagebus" },
                alertOnFailure = true
            }));
    }
    
    // Weekly report generation
    public async Task ScheduleWeeklyReport()
    {
        await _schedulerLogic.CreateCronSchedule(
            topic: "Reports.Weekly",
            cronExpression: "0 8 * * 1", // Every Monday at 8 AM
            parameters: JObject.FromObject(new
            {
                reportType = "sales",
                recipients = new[] { "manager@company.com", "sales@company.com" },
                includeCharts = true
            }));
    }
}
```

#### Event Handling for Scheduled Jobs
```csharp
public class ScheduledEventHandler : IAppEventConsumer
{
    private readonly ILogger<ScheduledEventHandler> _logger;
    private readonly EmailService _emailService;
    private readonly BackupService _backupService;
    
    public void ConsumeEvents(AppEvent appEvent)
    {
        switch (appEvent.Topic)
        {
            case "User.Reminder":
                HandleUserReminder(appEvent);
                break;
                
            case "System.Backup":
                HandleSystemBackup(appEvent);
                break;
                
            case "System.HealthCheck":
                HandleHealthCheck(appEvent);
                break;
                
            case "Reports.Weekly":
                HandleWeeklyReport(appEvent);
                break;
        }
    }
    
    private async Task HandleUserReminder(AppEvent appEvent)
    {
        var payload = BsonSerializer.Deserialize<ReminderPayload>(appEvent.EntityPayload);
        
        await _emailService.SendReminderAsync(
            payload.UserId,
            payload.Message,
            payload.Type);
    }
    
    private async Task HandleSystemBackup(AppEvent appEvent)
    {
        var payload = BsonSerializer.Deserialize<BackupPayload>(appEvent.EntityPayload);
        
        await _backupService.PerformBackupAsync(
            payload.BackupType,
            payload.RetentionDays);
    }
    
    private async Task HandleHealthCheck(AppEvent appEvent)
    {
        var payload = BsonSerializer.Deserialize<HealthCheckPayload>(appEvent.EntityPayload);
        
        var results = await _healthCheckService.CheckServicesAsync(payload.CheckServices);
        
        if (payload.AlertOnFailure && results.Any(r => !r.IsHealthy))
        {
            await _alertService.SendHealthAlertAsync(results);
        }
    }
}
```

#### Integration with Work Items
```csharp
public class WorkItemSchedulingExample
{
    private readonly SchedulerLogic _schedulerLogic;
    private readonly WorkItemLogic _workItemLogic;
    
    // Schedule follow-up tasks
    public async Task ScheduleFollowUp(Guid workItemId, DateTime followUpDate)
    {
        await _schedulerLogic.CreateOneTimeSchedule(
            topic: "WorkItem.FollowUp",
            executeAt: followUpDate,
            parameters: JObject.FromObject(new
            {
                workItemId = workItemId,
                action = "reminder",
                message = "Follow up required on this work item"
            }));
    }
    
    // Schedule automatic status updates
    public async Task ScheduleStatusEscalation(Guid workItemId)
    {
        // Escalate to manager if not resolved in 24 hours
        await _schedulerLogic.CreateOneTimeSchedule(
            topic: "WorkItem.Escalate",
            executeAt: DateTime.UtcNow.AddHours(24),
            parameters: JObject.FromObject(new
            {
                workItemId = workItemId,
                escalationLevel = "manager",
                reason = "Unresolved for 24 hours"
            }));
        
        // Auto-close if not resolved in 7 days
        await _schedulerLogic.CreateOneTimeSchedule(
            topic: "WorkItem.AutoClose",
            executeAt: DateTime.UtcNow.AddDays(7),
            parameters: JObject.FromObject(new
            {
                workItemId = workItemId,
                reason = "Auto-closed due to inactivity"
            }));
    }
}
```

### Best Practices

1. **Use appropriate schedule types** - Choose the right scheduling pattern for your needs
2. **Handle timezone considerations** - Be aware of UTC vs local time conversions
3. **Implement idempotency** - Ensure scheduled operations can be safely retried
4. **Monitor schedule health** - Track execution success and failure rates
5. **Use meaningful event topics** - Structure topics for easy event routing
6. **Include sufficient parameters** - Pass all necessary data in schedule parameters
7. **Handle long-running operations** - Use appropriate timeout and cancellation patterns
8. **Validate cron expressions** - Test cron expressions before creating schedules
9. **Plan for schedule cleanup** - Remove completed or obsolete schedules
10. **Log schedule execution** - Maintain audit trail of scheduled operations

---

## Notification System

The Notification System provides comprehensive multi-channel notification capabilities with advanced features including message regulation, duplicate suppression, digest consolidation, and audit trails. It supports email, SMS, voice calls, and in-app toast notifications with sophisticated timing and routing controls.

### Core Components

#### NotificationMessage
The primary message model supporting multiple notification channels:

```csharp
public class NotificationMessage
{
    // Message content
    public string Subject { get; set; } = "unknown";        // Message subject/title
    public string CreatorId { get; set; } = "unknown";      // Message creator ID
    
    // Channel-specific content
    public string? SMSText { get; set; }                    // SMS message text
    public string? EmailText { get; set; }                  // Email plain text
    public string? EmailHtmlText { get; set; }              // Email HTML content
    public string? ToastText { get; set; }                  // In-app toast text
    public string? CallText { get; set; }                   // Voice call text
    
    // Targeting
    public List<Guid> NotificationGroups { get; set; } = new(); // Multiple groups
    public Guid? NotificationGroup { get; set; }            // Single group
    public Guid? NotificationContact { get; set; }          // Direct contact
    
    // Message properties
    public LogLevel Severity { get; set; }                  // Message severity level
    
    // Regulation settings
    public bool WantDigest { get; set; }                    // Enable digest consolidation
    public bool WantSuppression { get; set; }               // Enable duplicate suppression
    public int SuppressionMinutes { get; set; }             // Suppression window
    public int DigestMinutes { get; set; }                  // Digest consolidation window
    public int DigestHead { get; set; }                     // Head items in digest
    public int DigestTail { get; set; }                     // Tail items in digest
}
```

#### NotificationService
Background service that processes notification messages:

```csharp
public class NotificationService : IHostedService, IDisposable
{
    public const string ExchangeName = "user_notification";
    public const string RouteName = "q_user_notification";
    
    private IMessageListener? _qListener;
    private readonly IMessageBusSpecifier _busSpec;
    private readonly IRegulatedNotificationLogic _logic;
    private readonly ILogger<NotificationService> _logger;
    
    public async Task StartAsync(CancellationToken cancellationToken)
    {
        if (_qListener != null)
        {
            // Configure message bus topology
            _busSpec
                .DeclareExchange(ExchangeName, ExchangeTypes.Direct)
                .SpecifyExchange(ExchangeName)
                .DeclareQueue(RouteName, RouteName);
            
            _logger.LogInformation($"User Notification Service listening on {ExchangeName}.{RouteName}");
            
            // Initialize listener
            _qListener.Initialize(ExchangeName, RouteName);
            _qListener.Listen(new KeyValuePair<Type, Action<object, CancellationToken, IMessageAcknowledge>>(
                typeof(NotificationMessage), ProcessMessage));
        }
        
        _logic.Initialize();
    }
    
    private void ProcessMessage(object msg, CancellationToken ct, IMessageAcknowledge ack)
    {
        try
        {
            ct.ThrowIfCancellationRequested();
            
            if (msg is NotificationMessage notification)
                AsyncHelper.RunSync(() => _logic.Notify(notification));
        }
        catch (Exception ex)
        {
            _logger.LogWarning("{trace}", ex.TraceInformation());
        }
    }
}
```

#### RegulatedNotificationLogic
Core logic that handles message routing, regulation, and delivery:

```csharp
public class RegulatedNotificationLogic : IDisposable, IRegulatedNotificationLogic
{
    private readonly ILogger<RegulatedNotificationLogic> _logger;
    private readonly IRepository<NotificationGroup> _groupRepo;
    private readonly IRepository<NotificationContact> _contactRepo;
    private readonly IRepository<NotificationAudit> _auditRepo;
    private readonly INotificationCore _notificationCore;
    
    // Regulation components
    private readonly SuppressionOrder<Suppressible<ExecuteNotifyCommand>> _suppresser;
    private readonly SuppressionResultReceiver<Suppressible<ExecuteNotifyCommand>> _suppresserReceiver;
    private readonly ConsolidateToDigestOrder<Digestible<ExecuteNotifyCommand>> _digester;
    private readonly DigestResultReceiver<ExecuteNotifyCommand> _digestReceiver;
    
    public async Task Notify(NotificationMessage msg)
    {
        msg.Requires().IsNotNull();
        
        bool hasTarget = msg.NotificationGroups.Any() ||
                        msg.NotificationGroup.HasValue ||
                        msg.NotificationContact.HasValue;
        hasTarget.Requires().IsTrue();
        
        using (PerfTrack.Stopwatch("Regulated Notify"))
        {
            if (msg.NotificationGroups.Any())
                await GroupsNotify(msg);
            else if (msg.NotificationGroup.HasValue)
                await GroupNotify(msg, msg.NotificationGroup.Value);
            else if (msg.NotificationContact.HasValue)
                await ContactNotify(msg, msg.NotificationContact.Value);
        }
    }
    
    private async Task GroupNotify(NotificationMessage msg, Guid notificationGroupId)
    {
        var (group, _) = await _groupRepo.LoadAsync(notificationGroupId);
        group.Guarantees().IsNotNull();
        group!.Active.Guarantees().IsTrue();
        
        var (contacts, _) = await _contactRepo.LoadManyAsync(group.Members.Select(m => m.Id));
        if (contacts.Any())
        {
            var tasks = contacts
                .Select(contact => ContactNotify(msg, contact))
                .ToArray();
            
            await Task.WhenAll(tasks);
        }
    }
    
    private async Task ContactNotify(NotificationMessage msg, NotificationContact contact)
    {
        // Channel validation
        bool channelSelected = msg.SMSText is not null ||
                              msg.EmailText is not null ||
                              msg.EmailHtmlText is not null ||
                              msg.CallText is not null ||
                              msg.ToastText is not null;
        channelSelected.Requires().IsNotEqualTo(false);
        
        // Time and severity-based routing
        var sevContactRules = contact.TimeSeverityTable.BySeverity(msg.Severity);
        var tzi = TimeZoneInfo.FromSerializedString(contact.TimeZoneInfoId);
        var timeContactRules = sevContactRules.ByTime(tzi);
        
        DateTime digestUntilTime = DateTime.MinValue;
        if (msg.WantDigest)
            digestUntilTime = AcceptDigestParameters(msg, tzi);
        
        // Route to appropriate channels
        if (msg.SMSText is not null && !string.IsNullOrWhiteSpace(contact.TextNumber))
            await DoNotificationByRoute(msg, timeContactRules.Text, ChannelType.Text, contact, digestUntilTime, SendText);
        
        var finalEmailText = msg.EmailHtmlText ?? msg.EmailText;
        if (finalEmailText is not null && !string.IsNullOrWhiteSpace(contact.EmailAddress))
            await DoNotificationByRoute(msg, timeContactRules.Email, ChannelType.Email, contact, digestUntilTime, SendEmail);
        
        if (msg.CallText is not null && !string.IsNullOrWhiteSpace(contact.CallNumber))
            await DoNotificationByRoute(msg, timeContactRules.Call, ChannelType.Call, contact, digestUntilTime, SendCall);
        
        if (msg.ToastText is not null)
            await DoNotificationByRoute(msg, timeContactRules.Toast, ChannelType.Toast, contact, digestUntilTime, SendToast);
    }
    
    private async Task DoNotificationByRoute(
        NotificationMessage message,
        ChannelRegulation regulation,
        ChannelType channelType,
        NotificationContact nContact,
        DateTime nDigestUntilTime,
        Func<NotificationContact, NotificationMessage, bool, Task> action)
    {
        // Determine routing strategy
        ChannelRegulation route = ChannelRegulation.Allow;
        if (message.WantSuppression) route = ChannelRegulation.Suppress;
        if (message.WantDigest) route = ChannelRegulation.Digest;
        if (message.WantSuppression && message.WantDigest) route = ChannelRegulation.DigestSuppressed;
        
        if (regulation > route) route = regulation;
        
        var exec = new ExecuteNotifyCommand
        {
            NotificationMessage = message,
            Contact = nContact,
            ExecuteChannel = channelType
        };
        
        switch (route)
        {
            case ChannelRegulation.Allow:
                await action(nContact, message, true);
                break;
                
            case ChannelRegulation.Suppress:
                await _suppresser.MaybeSuppressAsync(
                    new Suppressible<ExecuteNotifyCommand>(
                        exec,
                        message.SuppressionMinutes,
                        message.Subject,
                        ne => ne.NotificationMessage!.Subject,
                        ne => ne.NotificationMessage!.CreatorId ?? "none",
                        ne => nContact.UserRef.ToString(),
                        ne => nContact.Id.ToString()));
                break;
                
            case ChannelRegulation.Digest:
            case ChannelRegulation.DigestSuppressed:
                if (route == ChannelRegulation.DigestSuppressed)
                    exec.DigestSuppressed = true;
                    
                await _digester.ConsolidateIntoDigestAsync(
                    new Digestible<ExecuteNotifyCommand>(
                        exec, nDigestUntilTime, message.DigestHead, message.DigestTail,
                        message.Subject,
                        ne => ne.NotificationMessage!.Subject,
                        ne => ne.NotificationMessage!.CreatorId ?? "none",
                        ne => nContact.UserRef.ToString(),
                        ne => nContact.Id.ToString()));
                break;
        }
    }
}
```

#### NotificationContact
Represents a notification recipient with channel preferences:

```csharp
public class NotificationContact : IDataModel
{
    public Guid Id { get; set; }
    public int Version { get; set; }
    
    // Contact information
    public Guid UserRef { get; set; }                       // Associated user
    public string ContactTitle { get; set; }                // Display name
    public bool Active { get; set; } = true;                // Contact status
    
    // Channel addresses
    public string? EmailAddress { get; set; }               // Email address
    public string? TextNumber { get; set; }                 // SMS phone number
    public string? CallNumber { get; set; }                 // Voice call number
    
    // Preferences
    public string TimeZoneInfoId { get; set; }              // Timezone for scheduling
    public NotificationTimeSeverityTable TimeSeverityTable { get; set; } // Channel rules
    
    // Metadata
    public DateTime CreatedDate { get; set; }
    public DateTime UpdatedDate { get; set; }
    public List<string> Tags { get; set; } = new();
}

public class NotificationTimeSeverityTable
{
    public Dictionary<LogLevel, NotificationChannelsAllowed> SeverityRules { get; set; } = new();
    
    public NotificationChannelsAllowed BySeverity(LogLevel severity)
    {
        return SeverityRules.TryGetValue(severity, out var rules) 
            ? rules 
            : NotificationChannelsAllowed.Default;
    }
}

public class NotificationChannelsAllowed
{
    public Dictionary<TimeShift, ChannelRegulation> TimeRules { get; set; } = new();
    
    public ChannelRegulation ByTime(TimeZoneInfo timeZone)
    {
        var currentTime = TimeZoneInfo.ConvertTimeFromUtc(DateTime.UtcNow, timeZone);
        var currentShift = TimeShifts.GetCurrentShift(currentTime);
        
        return TimeRules.TryGetValue(currentShift, out var regulation)
            ? regulation
            : ChannelRegulation.Allow;
    }
    
    public static NotificationChannelsAllowed Default => new()
    {
        TimeRules = new Dictionary<TimeShift, ChannelRegulation>
        {
            { TimeShift.BusinessHours, ChannelRegulation.Allow },
            { TimeShift.AfterHours, ChannelRegulation.Digest },
            { TimeShift.Weekend, ChannelRegulation.Digest }
        }
    };
}

public enum ChannelRegulation
{
    Allow = 0,           // Send immediately
    Suppress = 1,        // Suppress duplicates
    Digest = 2,          // Consolidate into digest
    DigestSuppressed = 3 // Suppress then digest
}
```

#### NotificationGroup
Manages groups of notification contacts:

```csharp
public class NotificationGroup : IDataModel
{
    public Guid Id { get; set; }
    public int Version { get; set; }
    
    // Group information
    public string Name { get; set; }                        // Group name
    public string? Description { get; set; }                // Group description
    public bool Active { get; set; } = true;                // Group status
    
    // Membership
    public List<NotificationContactReference> Members { get; set; } = new();
    
    // Metadata
    public DateTime CreatedDate { get; set; }
    public DateTime UpdatedDate { get; set; }
    public Guid CreatedBy { get; set; }
    public List<string> Tags { get; set; } = new();
}

public class NotificationContactReference
{
    public Guid Id { get; set; }                            // Contact ID
    public string? Role { get; set; }                       // Member role
    public DateTime AddedDate { get; set; }                 // When added
    public bool Active { get; set; } = true;                // Member status
}
```

#### TwilioNotificationCore
Twilio-based implementation for SMS and voice notifications:

```csharp
public class TwilioNotificationCore : INotificationCore
{
    private readonly TwilioNotificationOptions _options;
    private readonly ILogger<TwilioNotificationCore> _logger;
    private readonly TwilioRestClient _twilioClient;
    
    public TwilioNotificationCore(
        IOptions<TwilioNotificationOptions> options,
        ILogger<TwilioNotificationCore> logger)
    {
        _options = options.Value;
        _logger = logger;
        _twilioClient = new TwilioRestClient(_options.AccountSid, _options.AuthToken);
    }
    
    public async Task SendText(string phoneNumber, string message)
    {
        try
        {
            var messageResource = await MessageResource.CreateAsync(
                body: message,
                from: new PhoneNumber(_options.FromPhoneNumber),
                to: new PhoneNumber(phoneNumber),
                client: _twilioClient);
            
            _logger.LogInformation("SMS sent successfully. SID: {MessageSid}", messageResource.Sid);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to send SMS to {PhoneNumber}", phoneNumber);
            throw;
        }
    }
    
    public async Task SendCall(string phoneNumber, string message)
    {
        try
        {
            var call = await CallResource.CreateAsync(
                url: new Uri(_options.VoiceCallbackUrl),
                to: new PhoneNumber(phoneNumber),
                from: new PhoneNumber(_options.FromPhoneNumber),
                client: _twilioClient);
            
            _logger.LogInformation("Voice call initiated successfully. SID: {CallSid}", call.Sid);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to initiate call to {PhoneNumber}", phoneNumber);
            throw;
        }
    }
    
    public async Task SendEmail(string emailAddress, string displayName, string subject, string? textBody, string? htmlBody)
    {
        // Delegate to email service (SendGrid, SMTP, etc.)
        await _emailService.SendEmailAsync(emailAddress, displayName, subject, textBody, htmlBody);
    }
    
    public async Task SendToast(Guid userId, string subject, string message)
    {
        // Create web notification for user
        var webNotification = new WebNotification
        {
            UserId = userId,
            Subject = subject,
            Message = message,
            NotificationType = WebNotificationKind.Toast,
            CreatedDate = DateTime.UtcNow,
            IsRead = false
        };
        
        await _webNotificationRepository.CreateAsync(webNotification);
        
        // Signal real-time notification if user is online
        await _webNotificationSink.NotifyUserAsync(userId, webNotification);
    }
}

public class TwilioNotificationOptions
{
    public string AccountSid { get; set; } = string.Empty;
    public string AuthToken { get; set; } = string.Empty;
    public string FromPhoneNumber { get; set; } = string.Empty;
    public string VoiceCallbackUrl { get; set; } = string.Empty;
}
```

#### WebNotification
In-app notification system:

```csharp
public class WebNotification : IDataModel
{
    public Guid Id { get; set; }
    public int Version { get; set; }
    
    // Notification content
    public Guid UserId { get; set; }                        // Target user
    public string Subject { get; set; }                     // Notification title
    public string Message { get; set; }                     // Notification content
    public WebNotificationKind NotificationType { get; set; } // Notification type
    
    // State
    public bool IsRead { get; set; } = false;               // Read status
    public DateTime? ReadDate { get; set; }                 // When read
    public DateTime CreatedDate { get; set; }               // Creation time
    public DateTime? ExpiryDate { get; set; }               // Optional expiry
    
    // Metadata
    public string? ActionUrl { get; set; }                  // Optional action link
    public JObject? Data { get; set; }                      // Additional data
    public int Priority { get; set; } = 0;                  // Display priority
}

public enum WebNotificationKind
{
    Info = 0,
    Success = 1,
    Warning = 2,
    Error = 3,
    Toast = 4,
    Alert = 5
}

public interface IWebNotificationSink
{
    Task NotifyUserAsync(Guid userId, WebNotification notification);
    Task MarkAsReadAsync(Guid userId, Guid notificationId);
    Task<List<WebNotification>> GetUnreadNotificationsAsync(Guid userId);
}
```

### Message Regulation Features

#### Duplicate Suppression
Prevents sending duplicate messages within a specified time window:

```csharp
// Enable suppression for 30 minutes
var message = new NotificationMessage
{
    Subject = "System Alert",
    EmailText = "Database connection lost",
    WantSuppression = true,
    SuppressionMinutes = 30,
    NotificationGroup = alertGroupId
};
```

#### Digest Consolidation
Consolidates multiple messages into a single digest:

```csharp
// Enable digest consolidation for 60 minutes
var message = new NotificationMessage
{
    Subject = "Order Updates",
    EmailText = "Order #12345 has been shipped",
    WantDigest = true,
    DigestMinutes = 60,
    DigestHead = 5,     // Show first 5 messages
    DigestTail = 5,     // Show last 5 messages
    NotificationGroup = ordersGroupId
};
```

#### Combined Regulation
Suppress duplicates and then consolidate into digests:

```csharp
var message = new NotificationMessage
{
    Subject = "Performance Alert",
    EmailText = "CPU usage above 90%",
    WantSuppression = true,
    WantDigest = true,
    SuppressionMinutes = 15,
    DigestMinutes = 60,
    NotificationGroup = opsTeamId
};
```

### Usage Examples

#### Basic Notification Sending
```csharp
public class NotificationExamples
{
    private readonly IMessagePublisher _messagePublisher;
    
    // Send immediate notification
    public async Task SendWelcomeEmail(Guid userId)
    {
        var message = new NotificationMessage
        {
            Subject = "Welcome to Our Platform!",
            EmailText = "Thank you for joining us. Here's how to get started...",
            EmailHtmlText = "<h1>Welcome!</h1><p>Thank you for joining us...</p>",
            NotificationContact = userId,
            Severity = LogLevel.Information
        };
        
        await _messagePublisher.SendAsync(message, NotificationService.RouteName);
    }
    
    // Send multi-channel alert
    public async Task SendSecurityAlert(Guid securityGroupId, string alertDetails)
    {
        var message = new NotificationMessage
        {
            Subject = "SECURITY ALERT",
            EmailText = $"Security incident detected: {alertDetails}",
            SMSText = $"SECURITY ALERT: {alertDetails}",
            ToastText = $"Security Alert: {alertDetails}",
            NotificationGroup = securityGroupId,
            Severity = LogLevel.Critical,
            WantSuppression = true,
            SuppressionMinutes = 5 // Prevent spam during incidents
        };
        
        await _messagePublisher.SendAsync(message, NotificationService.RouteName);
    }
    
    // Send digest-enabled notifications
    public async Task SendOrderNotification(Guid customerId, string orderDetails)
    {
        var message = new NotificationMessage
        {
            Subject = "Order Update",
            EmailText = $"Your order has been updated: {orderDetails}",
            ToastText = $"Order update: {orderDetails}",
            NotificationContact = customerId,
            Severity = LogLevel.Information,
            WantDigest = true,
            DigestMinutes = 120, // 2-hour digest window
            DigestHead = 3,
            DigestTail = 2
        };
        
        await _messagePublisher.SendAsync(message, NotificationService.RouteName);
    }
}
```

#### Rule Action Integration
```csharp
public class RuleActionRequestNotification : IRuleAction
{
    private readonly IMessagePublisher _messagePublisher;
    
    public async Task<object> ExecuteAsync(
        Dictionary<string, object?> args,
        AppEvent appEvent,
        RuleEvaluationContext context)
    {
        var groupByTags = args.GetValueOrDefault("GroupByTags") as string[];
        var subject = args.GetValueOrDefault("Subject") as string;
        var emailText = args.GetValueOrDefault("EmailText") as string;
        var smsText = args.GetValueOrDefault("SMSText") as string;
        var toastText = args.GetValueOrDefault("ToastText") as string;
        var severity = Enum.Parse<LogLevel>(args.GetValueOrDefault("Severity") as string ?? "Information");
        
        // Find notification groups by tags
        var groups = await FindGroupsByTags(groupByTags);
        
        var message = new NotificationMessage
        {
            Subject = subject,
            EmailText = emailText,
            SMSText = smsText,
            ToastText = toastText,
            NotificationGroups = groups.Select(g => g.Id).ToList(),
            Severity = severity,
            CreatorId = appEvent.OriginId?.ToString() ?? "system"
        };
        
        await _messagePublisher.SendAsync(message, NotificationService.RouteName);
        
        return new { sent = true, groupCount = groups.Count };
    }
}
```

#### Advanced Routing with Time-Based Rules
```csharp
public class NotificationContactService
{
    public async Task SetupManagerContact(Guid userId, Guid managerId)
    {
        var contact = new NotificationContact
        {
            UserRef = userId,
            ContactTitle = "John Manager",
            EmailAddress = "john.manager@company.com",
            TextNumber = "+1234567890",
            CallNumber = "+1234567890",
            TimeZoneInfoId = TimeZoneInfo.Local.ToSerializedString(),
            
            // Configure time and severity-based routing
            TimeSeverityTable = new NotificationTimeSeverityTable
            {
                SeverityRules = new Dictionary<LogLevel, NotificationChannelsAllowed>
                {
                    // Critical: Always allow all channels
                    [LogLevel.Critical] = new NotificationChannelsAllowed
                    {
                        TimeRules = new Dictionary<TimeShift, ChannelRegulation>
                        {
                            { TimeShift.BusinessHours, ChannelRegulation.Allow },
                            { TimeShift.AfterHours, ChannelRegulation.Allow },
                            { TimeShift.Weekend, ChannelRegulation.Allow }
                        }
                    },
                    
                    // Warning: Business hours immediate, otherwise digest
                    [LogLevel.Warning] = new NotificationChannelsAllowed
                    {
                        TimeRules = new Dictionary<TimeShift, ChannelRegulation>
                        {
                            { TimeShift.BusinessHours, ChannelRegulation.Allow },
                            { TimeShift.AfterHours, ChannelRegulation.Digest },
                            { TimeShift.Weekend, ChannelRegulation.Digest }
                        }
                    },
                    
                    // Info: Always digest outside business hours
                    [LogLevel.Information] = new NotificationChannelsAllowed
                    {
                        TimeRules = new Dictionary<TimeShift, ChannelRegulation>
                        {
                            { TimeShift.BusinessHours, ChannelRegulation.Allow },
                            { TimeShift.AfterHours, ChannelRegulation.Digest },
                            { TimeShift.Weekend, ChannelRegulation.Suppress }
                        }
                    }
                }
            }
        };
        
        await _contactRepository.CreateAsync(contact);
    }
}
```

### Best Practices

1. **Use appropriate severity levels** - Match LogLevel to message importance
2. **Enable regulation wisely** - Use suppression for alerts, digests for updates
3. **Configure time-based rules** - Respect recipient preferences and schedules
4. **Provide multiple channels** - Allow fallback options for critical messages
5. **Monitor delivery rates** - Track success/failure metrics
6. **Maintain contact hygiene** - Keep contact information current
7. **Use meaningful subjects** - Help recipients prioritize messages
8. **Test notification flows** - Verify delivery across all channels
9. **Handle failures gracefully** - Implement retry logic and fallbacks
10. **Audit notification activity** - Maintain compliance and debugging trails

---